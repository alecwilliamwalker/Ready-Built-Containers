{"file_contents":{"src/App.css":{"content":"/* Global full-viewport layout */\nhtml, body, #root {\n  height: 100%;\n  width: 100%;\n  margin: 0;\n}\n\n#root {\n  display: flex;\n  flex-direction: column;\n  /* kill any template constraint */\n  max-width: none !important;\n  padding: 0 !important;\n}\n\n/* Stretchy app wrappers */\n.app, .main, .content {\n  display: flex;\n  flex: 1 1 auto;\n  min-width: 0;\n  min-height: 0;\n  width: 100%;\n}\n\n/* Report page wrappers */\n.report-wrap {\n  display: flex;\n  flex: 1 1 auto;\n  min-width: 0;\n  min-height: 0;\n  width: 100%;\n}\n\n.canvas-wrap { display:flex; flex:1; min-height:0; width: 100%; }\n.canvas {\n  position: relative;\n  flex: 1 1 auto;\n  width: 100%;\n  min-height: calc(100vh - 140px);\n  max-width: none; /* remove any inherited clamps */\n  background: #111;\n  overflow: auto;\n  padding: 16px;\n}\n\n/* Hard override while refactoring ancestor clamps */\n.report-wrap, .canvas {\n  width: 100vw !important;\n  max-width: none !important;\n}\n\n/* Existing styles retained below */\nbody {\n  margin: 0;\n  font-family: system-ui, Arial, sans-serif;\n  background: #1f1f1f;\n  color: #efefef;\n}\n\nh1 { text-align: center; }\n\ntable { margin: 2rem auto; border-collapse: collapse; }\n\ntd { border: 1px solid #4a4a4a; width: 100px; }\n\ninput {\n  width: 100%;\n  height: 28px;\n  padding: 4px;\n  box-sizing: border-box;\n  background: #ffffff;\n  color: #000000;\n  border: none;\n  outline: none;\n}\n\n/* Selected cell visuals */\ntd.selected { outline: 2px solid #4f9cff; outline-offset: -2px; }\n\ntd.selected input { background: #fff8cc; }\n\n/* Headers */\nth.col-head, th.row-head {\n  background: #f3f3f3;\n  color: #333;\n  border: 1px solid #4a4a4a;\n  font-weight: 600;\n  user-select: none;\n}\n\nth.active-head { background: #cfe7ff; }\n\n/* Optional: soft tint for whole selected row/col */\ntd.tint-row { background: #f8fbff; }\n\ntd.tint-col { background: #f8fbff; }\n\n/* ReportPad contenteditable styles */\n.pad {\n  display: block;\n  width: clamp(720px, 70vw, 960px);\n  min-height: calc(100vh - 140px);\n  margin: 24px auto;\n  padding: 16px 20px 80px;\n  box-sizing: border-box;\n  outline: none;\n  overflow-y: auto;\n  line-height: 1.5;\n  font: 14px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;\n  white-space: normal;\n}\n.pad p, .pad div { position: relative; margin: 0 0 8px; }\n.pad [data-error]::after { content: attr(data-error); color: #c62828; font-size: 12px; margin-left: 8px; }\n.result-chip { margin-left: 8px; opacity: .9; white-space: nowrap; }\n\n/* Report canvas styles */\n.calc-box {\n  position: absolute;\n  min-width: 160px;\n  width: var(--w, auto);\n}\n/* Resize handle: unobtrusive */\n.resize-handle {\n  position: absolute;\n  right: -6px;\n  bottom: -6px;\n  width: 12px;\n  height: 12px;\n  cursor: nwse-resize;\n  border-radius: 3px;\n  background: #4a4a4a;\n  opacity: 0;\n  transition: opacity 120ms ease-in-out;\n  pointer-events: auto;\n}\n.calc-box:hover .resize-handle,\n.calc-box.selected .resize-handle { opacity: 0.7; }\n.calc-box.edit .resize-handle { display: none; }\n.calc-box.edit { cursor: text; }\n.calc-box.render { cursor: move; }\n.calc-box.selected { outline: 2px solid #4f9cff; outline-offset: 0; }\n.calc-input { width: 100%; background: transparent; border: none; outline: none; color: #ddd; font: 14px/1.4 ui-monospace, Menlo, Consolas, monospace; }\n.calc-render { font: 14px/1.4 ui-monospace, Menlo, Consolas, monospace; white-space: pre-wrap; }\n.calc-render * { cursor: text; }\n.calc-error { color: #e57373; font-size: 12px; margin-left: 6px; }\n\n.marquee {\n  position: absolute;\n  pointer-events: none;\n  border: 1px dashed #4f9cff;\n  background: rgba(79,156,255,0.15);\n}\n","size_bytes":3567},"src/App.tsx":{"content":"import React, { useRef, useState, type KeyboardEvent as KBEvent, useEffect, useMemo } from \"react\";\nimport \"./App.css\";\nimport { evaluateWithGrid } from \"./unified_parser\";\nimport { clearVariablesInCell } from \"./referencing/names\";\nimport TopBar from \"./components/TopBar\";\nimport * as InsertBridge from \"./referencing/insertTarget\";\nimport { parseAddress as parseA1Address, indexToCol as a1IndexToCol } from \"./referencing/a1\";\nimport Tabs from \"./components/Tabs\";\nimport ReportCanvas from \"./frames/ReportCanvas/ReportCanvas\";\nimport { History } from \"./history/History\";\nimport { AppCommandCtx } from \"./history/ctx\";\nimport { SetCellValueCommand } from \"./history/commands/sheet/SetCellValueCommand\";\nimport { PasteCommand } from \"./history/commands/sheet/PasteCommand\";\nimport { createHistoryProxy } from \"./history/proxy\";\nimport { bindGlobalHotkeys } from \"./input/hotkeys\";\n\ntype CellValue = string;\n\nconst indexToCol = a1IndexToCol;\n\n// use centralized helpers in referencing/a1\n\nfunction parseAddress(addr: string, maxRows: number, maxCols: number): { r: number; c: number } | null {\n  const rc = parseA1Address(addr);\n  if (!rc) return null;\n  if (rc.r < 0 || rc.c < 0 || rc.r >= maxRows || rc.c >= maxCols) return null;\n  return rc;\n}\n\ntype SheetSize = 'small' | 'medium' | 'large';\n\nconst SIZE_PRESETS: Record<SheetSize, { rows: number; cols: number }> = {\n  small: { rows: 200, cols: 26 },\n  medium: { rows: 1000, cols: 50 },\n  large: { rows: 5000, cols: 80 },\n};\n\nexport default function App() {\n  // Boot checkpoint: App render entered\n  if (import.meta.env.DEV) {\n    // eslint-disable-next-line no-console\n    console.log('[BOOT] App: render start');\n  }\n  // optional boot mark (no await in render)\n  try { (window as any).__recordBoot && (window as any).__recordBoot('[BOOT] App render start'); } catch {}\n  const [sheetSize, setSheetSize] = useState<SheetSize>('medium');\n  const [numRows, setNumRows] = useState<number>(SIZE_PRESETS['medium'].rows);\n  const [numCols, setNumCols] = useState<number>(SIZE_PRESETS['medium'].cols);\n\n  type TabKind = 'sheet' | 'report';\n  type AppTab = { id: string; label: string; kind: TabKind };\n  const TABS_KEY = 'engineering-notebook:tabs';\n  const CURRENT_TAB_KEY = 'engineering-notebook:currentTab';\n  const defaultTabs: AppTab[] = [ { id: 'sheet', label: 'Sheet', kind: 'sheet' }, { id: 'report', label: 'Report', kind: 'report' } ];\n  const [tabsState, setTabsState] = useState<AppTab[]>(() => {\n    try { const raw = localStorage.getItem(TABS_KEY); if (raw) { const arr = JSON.parse(raw); if (Array.isArray(arr)) return arr; } } catch {}\n    return defaultTabs;\n  });\n  const [activeTab, setActiveTab] = useState<string>(() => localStorage.getItem(CURRENT_TAB_KEY) || 'report');\n  useEffect(() => { try { localStorage.setItem(TABS_KEY, JSON.stringify(tabsState)); } catch {} }, [tabsState]);\n  useEffect(() => { try { localStorage.setItem(CURRENT_TAB_KEY, activeTab); } catch {} }, [activeTab]);\n\n  const [data, setData] = useState<CellValue[][]>(\n    Array.from({ length: numRows }, () => Array(numCols).fill(\"\")\n  ));\n  // History: shared across sheet+report\n  const historyRef = useRef<History | null>(null);\n  // const ctxRef = useRef<AppCommandCtx | null>(null);\n  const boxesAccessorRef = useRef<{ get: () => any[]; set: (next: any[] | ((prev: any[]) => any[])) => void } | null>(null);\n  const historyProxy = useMemo(() => createHistoryProxy(), []);\n  // Build a CommandCtx adapter over current state\n  const gridAccessor = useMemo(() => ({\n    get: (r: number, c: number) => ({ value: data[r]?.[c] ?? \"\" }),\n    set: (r: number, c: number, value: string) => {\n      // Clear variables defined by this cell before changing its value\n      const cellKey = `${r}:${c}`;\n      clearVariablesInCell(cellKey);\n      \n      setData(prev => { const copy = prev.map(row => [...row]); if (!copy[r]) return prev; copy[r][c] = value; return copy; });\n    }\n  }), [data]);\n  const boxesAccessor = useMemo(() => ({\n    get: () => boxesAccessorRef.current ? boxesAccessorRef.current.get() : [],\n    set: (next: any[] | ((prev: any[]) => any[])) => { boxesAccessorRef.current?.set(next); }\n  }), []);\n  // Defer History creation and ctx binding until after mount\n  const initOnceRef = useRef(false);\n  const [historyBadge, setHistoryBadge] = useState<{ u: number; r: number }>({ u: 0, r: 0 });\n  useEffect(() => {\n    if (initOnceRef.current) return;\n    initOnceRef.current = true;\n    const real = new History();\n    const ctx = new AppCommandCtx(gridAccessor, boxesAccessor);\n    real.setCtx(ctx);\n    historyRef.current = real;\n    historyProxy.setReal(real);\n    if (import.meta.env.DEV) {\n      // eslint-disable-next-line no-console\n      console.log('[BOOT] App: History setCtx');\n    }\n    const unsub = real.onChange(() => {\n      const s = (real as any).debugStacks?.();\n      if (s) setHistoryBadge({ u: s.undoLen, r: s.redoLen });\n    });\n    return () => { unsub?.(); };\n  }, [gridAccessor, boxesAccessor, historyProxy]);\n\n  // Bind global hotkeys once History is ready\n  useEffect(() => {\n    if (!historyProxy.isReady()) return;\n    const unbind = bindGlobalHotkeys({\n      history: historyProxy as any,\n      setTool: (t) => { /* tool managed in ReportCanvas; we only handle 'v'/'a' via side-effects if needed */ },\n      addBoxAtCenter: () => { /* ReportCanvas handles add at center; no-op here */ },\n      isEditingInApp: () => {\n        // Treat report input editing as app-owned so undo/redo go to History\n        const el = document.activeElement as HTMLElement | null;\n        if (!el) return false;\n        // Any element within canvas or with class calc-input is considered app-owned editing\n        const withinCanvas = !!el.closest('.canvas');\n        return withinCanvas;\n      },\n    });\n    return () => unbind();\n  }, [historyProxy]);\n  const [sel, setSel] = useState<{ r: number; c: number }>({ r: 0, c: 0 });\n  const [formula, setFormula] = useState<string>(\"\");\n  const [editing, setEditing] = useState<{ r: number; c: number } | null>(null);\n  const [activeExternalEdit, setActiveExternalEdit] = useState<string>(\"\");\n  const [hotkeysOpen, setHotkeysOpen] = useState(false);\n  // Bump to force re-render when sticky insert target buffer changes\n  const [insertVersion, setInsertVersion] = useState(0);\n  useEffect(() => {\n    const unsub = InsertBridge.subscribeInsertTarget(() => {\n      setInsertVersion((v) => v + 1);\n    });\n    return () => { try { unsub?.(); } catch {} };\n  }, []);\n  const [hotkeys, setHotkeys] = useState<Record<string, string>>(() => {\n    try { const raw = localStorage.getItem('engineering-notebook:hotkeys'); if (raw) return JSON.parse(raw); } catch {}\n    return {\n      undo: 'Control+z',\n      save: 'Control+s',\n      load: 'Control+o',\n      addBox: 'Shift+a',\n      fullWidth: 'f',\n      reportSelect: 'v',\n      reportAdd: 'a',\n    };\n  });\n  const persistHotkeys = (next: Record<string,string>) => { setHotkeys(next); try { localStorage.setItem('engineering-notebook:hotkeys', JSON.stringify(next)); } catch {} };\n\n  const cellRefs = useRef<(HTMLInputElement | null)[][]>([]);\n  const formulaRef = useRef<HTMLInputElement | null>(null);\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const originalEditValueRef = useRef<string>(\"\");\n\n  const clamp = (n: number, min: number, max: number) => Math.max(min, Math.min(max, n));\n\n  const isEditingCell = (r: number, c: number) => editing?.r === r && editing?.c === c;\n\n  const selectCell = (r: number, c: number) => {\n    const rr = clamp(r, 0, numRows - 1);\n    const cc = clamp(c, 0, numCols - 1);\n    setSel({ r: rr, c: cc });\n    setFormula(data[rr][cc]);\n    setEditing(null);\n    setTimeout(() => containerRef.current?.focus(), 0);\n  };\n\n  // const focusCell = (r: number, c: number) => {\n  //   const rr = clamp(r, 0, numRows - 1);\n  //   const cc = clamp(c, 0, numCols - 1);\n  //   setSel({ r: rr, c: cc });\n  //   setFormula(data[rr][cc]);\n  //   setTimeout(() => cellRefs.current[rr]?.[cc]?.focus(), 0);\n  // };\n\n  const enterEditMode = (r: number, c: number) => {\n    originalEditValueRef.current = data[r][c];\n    setEditing({ r, c });\n    setTimeout(() => cellRefs.current[r]?.[c]?.focus(), 0);\n  };\n\n  const handleChange = (row: number, col: number, value: string) => {\n    if (!historyProxy.isReady()) return; // guard pre-ready\n    historyProxy.push(new SetCellValueCommand(row, col, value));\n    if (row === sel.r && col === sel.c) setFormula(value);\n  };\n\n  const onInputKeyDown = (e: KBEvent<HTMLInputElement>, r: number, c: number) => {\n    if (e.key === \"Enter\") {\n      e.preventDefault();\n      setEditing(null);\n      if (e.shiftKey) selectCell(r - 1, c);\n      else selectCell(r + 1, c);\n    } else if (e.key === \"Tab\") {\n      e.preventDefault();\n      setEditing(null);\n      if (e.shiftKey) selectCell(r, c - 1);\n      else selectCell(r, c + 1);\n    } else if (e.key === \"Escape\") {\n      e.preventDefault();\n      const original = originalEditValueRef.current;\n      setData((prev) => { const copy = prev.map((rowArr) => [...rowArr]); copy[r][c] = original; return copy; });\n      setFormula(original);\n      setEditing(null);\n      setTimeout(() => containerRef.current?.focus(), 0);\n    }\n  };\n\n  const gridKeyDown = async (e: React.KeyboardEvent<HTMLDivElement>) => {\n    if (editing) return; // allow input to handle its own keys\n\n    // Navigation in selection mode\n    if (e.key === \"Enter\" && !e.shiftKey && !e.altKey && !e.ctrlKey && !e.metaKey) {\n      e.preventDefault();\n      enterEditMode(sel.r, sel.c);\n      return;\n    }\n\n    if (e.key === \"Tab\") {\n      e.preventDefault();\n      selectCell(sel.r, sel.c + (e.shiftKey ? -1 : 1));\n      return;\n    }\n\n    if (e.key === \"ArrowRight\") { e.preventDefault(); selectCell(sel.r, sel.c + 1); return; }\n    if (e.key === \"ArrowLeft\") { e.preventDefault(); selectCell(sel.r, sel.c - 1); return; }\n    if (e.key === \"ArrowDown\") { e.preventDefault(); selectCell(sel.r + 1, sel.c); return; }\n    if (e.key === \"ArrowUp\") { e.preventDefault(); selectCell(sel.r - 1, sel.c); return; }\n\n    const isCopy = (e.ctrlKey || e.metaKey) && (e.key === \"c\" || e.key === \"C\");\n    const isCut = (e.ctrlKey || e.metaKey) && (e.key === \"x\" || e.key === \"X\");\n    const isPaste = (e.ctrlKey || e.metaKey) && (e.key === \"v\" || e.key === \"V\");\n\n    if (isCopy || isCut) {\n      e.preventDefault();\n      const raw = data[sel.r][sel.c] ?? \"\";\n      try {\n        await navigator.clipboard.writeText(raw);\n      } catch {\n        // Fallback copy via hidden textarea\n        const ta = document.createElement(\"textarea\");\n        ta.value = raw;\n        ta.style.position = \"fixed\";\n        ta.style.opacity = \"0\";\n        ta.style.pointerEvents = \"none\";\n        ta.style.left = \"-9999px\";\n        document.body.appendChild(ta);\n        ta.focus();\n        ta.select();\n        try { document.execCommand(\"copy\"); } finally { document.body.removeChild(ta); }\n      }\n      if (isCut) {\n        setData((prev) => { const copy = prev.map((r) => [...r]); copy[sel.r][sel.c] = \"\"; return copy; });\n        setFormula(\"\");\n      }\n      return;\n    }\n\n    if (isPaste) {\n      e.preventDefault();\n      try {\n        const text = await navigator.clipboard.readText();\n        if (text == null) return;\n        const norm = text.replace(/\\r/g, \"\");\n        const rowsArr = norm.split(\"\\n\");\n        // Drop trailing empty line from some clipboard sources\n        const cleanedRows = rowsArr.length > 1 && rowsArr[rowsArr.length - 1] === \"\" ? rowsArr.slice(0, -1) : rowsArr;\n        const grid = cleanedRows.map((line) => line.split(\"\\t\"));\n        if (historyProxy.isReady()) historyProxy.push(new PasteCommand(sel.r, sel.c, grid));\n        setFormula(() => {\n          const topLeft = grid[0]?.[0] ?? \"\";\n          return topLeft;\n        });\n      } catch {\n        // Ignore if clipboard read fails\n      }\n      return;\n    }\n  };\n\n  const displayFor = (r: number, c: number, raw: string) => {\n    if (isEditingCell(r, c)) return raw;\n    const rowRefs = cellRefs.current[r];\n    const el = rowRefs ? rowRefs[c] : undefined;\n    const isActive = el != null && document.activeElement === el;\n    if (isActive) return raw;\n    if (raw.trim() === \"\") return \"\";\n    try { const val = evaluateWithGrid(data as string[][], raw, `${r}:${c}`); return String(val); }\n    catch { return raw; }\n  };\n\n  const addr = `${indexToCol(sel.c)}${sel.r + 1}`;\n  const onFormulaChange = (next: string) => {\n    setFormula(next);\n    setData((prev) => { const copy = prev.map((r) => [...r]); copy[sel.r][sel.c] = next; return copy; });\n  };\n\n  const getCellDisplay = (r: number, c: number): string => {\n    const raw = data[r]?.[c] ?? \"\";\n    if (raw.trim() === \"\") return \"\";\n    try { const val = evaluateWithGrid(data as string[][], raw, `${r}:${c}`); return String(val); }\n    catch { return raw; }\n  };\n\n  // Large sheet virtualization (row windowing)\n  const rowHeight = 28 + 2; // input height + borders\n  const headerHeight = 28 + 2; // header cell height\n  const [scrollTop, setScrollTop] = useState(0);\n  // const viewportRows = 20; // default; refined in render via container height\n  const buffer = 10;\n  const onScroll: React.UIEventHandler<HTMLDivElement> = (e) => {\n    setScrollTop((e.target as HTMLDivElement).scrollTop);\n  };\n\n  const isVirtualized = sheetSize !== 'small';\n  const startRow = isVirtualized ? Math.max(0, Math.floor((scrollTop - headerHeight) / rowHeight) - buffer) : 0;\n  const endRow = isVirtualized ? Math.min(numRows, startRow + Math.ceil((600 /*approx*/)/rowHeight) + buffer * 2) : numRows;\n\n  // Force Report canvas remount on load to pick up new docs\n  const [reportVersion, setReportVersion] = useState(0);\n\n  // Per-sheet storage keyed by tab id\n  const SHEET_BASE = 'engineering-notebook:sheet:v2';\n  const sheetKey = (id: string) => `${SHEET_BASE}:${id}`;\n  const makeBlankGrid = (r = numRows, c = numCols): CellValue[][] => Array.from({ length: r }, () => Array(c).fill(\"\"));\n  const loadSheet = (id: string): { data: CellValue[][]; sel: { r: number; c: number }; size?: SheetSize } => {\n    try {\n      const raw = localStorage.getItem(sheetKey(id));\n      if (!raw) return { data: makeBlankGrid(), sel: { r: 0, c: 0 }, size: 'medium' };\n      const saved = JSON.parse(raw);\n      const size: SheetSize = saved?.size === 'small' || saved?.size === 'medium' || saved?.size === 'large' ? saved.size : 'medium';\n      const dims = SIZE_PRESETS[size];\n      const loadedData: CellValue[][] = Array.isArray(saved?.data) ? ensureDataDims(saved.data, dims.rows, dims.cols) : makeBlankGrid(dims.rows, dims.cols);\n      const loadedSel = saved?.sel && typeof saved.sel.r === 'number' && typeof saved.sel.c === 'number' ? saved.sel : { r: 0, c: 0 };\n      return { data: loadedData, sel: loadedSel, size };\n    } catch {\n      return { data: makeBlankGrid(), sel: { r: 0, c: 0 }, size: 'medium' };\n    }\n  };\n  const saveSheet = (id: string, payload: { data: CellValue[][]; sel: { r: number; c: number }; size?: SheetSize }) => {\n    try { localStorage.setItem(sheetKey(id), JSON.stringify(payload)); } catch {}\n  };\n\n  const getTabKind = (id: string): TabKind | undefined => tabsState.find(t => t.id === id)?.kind;\n  const isSheetTab = (id: string) => getTabKind(id) === 'sheet';\n\n  // Keep live refs of current data/sel for saving on tab switches\n  const dataRef = useRef(data); useEffect(() => { dataRef.current = data; }, [data]);\n  const selRef = useRef(sel); useEffect(() => { selRef.current = sel; }, [sel]);\n  const prevActiveRef = useRef<string>(activeTab);\n\n  // Utilities to ensure data and refs match current dims\n  function ensureDataDims(d: CellValue[][], r: number, c: number): CellValue[][] {\n    const out = d.map(row => row.slice(0, c));\n    if (out.length < r) {\n      for (let i = out.length; i < r; i += 1) out.push(Array(c).fill(\"\"));\n    }\n    for (let i = 0; i < out.length; i += 1) {\n      if (out[i].length < c) out[i] = [...out[i], ...Array(c - out[i].length).fill(\"\")];\n    }\n    return out.slice(0, r);\n  }\n\n  function ensureCellRefs(r: number, c: number) {\n    const refs = cellRefs.current;\n    while (refs.length < r) refs.push([]);\n    for (let i = 0; i < r; i += 1) {\n      while (refs[i].length < c) refs[i].push(null);\n      if (refs[i].length > c) refs[i].length = c;\n    }\n    if (refs.length > r) refs.length = r;\n  }\n\n  useEffect(() => { ensureCellRefs(numRows, numCols); }, [numRows, numCols]);\n\n  // On mount: if starting on a sheet tab, load that sheet\n  useEffect(() => {\n    if (import.meta.env.DEV) {\n      // eslint-disable-next-line no-console\n      console.log('[BOOT] App: initial mount effect');\n    }\n    if (isSheetTab(activeTab)) {\n      const s = loadSheet(activeTab);\n      const size = s.size ?? 'medium';\n      setSheetSize(size);\n      setNumRows(SIZE_PRESETS[size].rows);\n      setNumCols(SIZE_PRESETS[size].cols);\n      setData(ensureDataDims(s.data, SIZE_PRESETS[size].rows, SIZE_PRESETS[size].cols));\n      setSel(s.sel);\n      const f = s.data[s.sel.r]?.[s.sel.c] ?? \"\";\n      setFormula(f);\n      // Ensure external edit state is cleared for sheet mode\n      setActiveExternalEdit(\"\");\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // When switching tabs: persist previous sheet, load next sheet if applicable\n  useEffect(() => {\n    const prevId = prevActiveRef.current;\n    if (isSheetTab(prevId)) {\n      saveSheet(prevId, { data: dataRef.current, sel: selRef.current, size: sheetSize });\n    }\n    if (isSheetTab(activeTab)) {\n      const s = loadSheet(activeTab);\n      const size = s.size ?? 'medium';\n      setSheetSize(size);\n      setNumRows(SIZE_PRESETS[size].rows);\n      setNumCols(SIZE_PRESETS[size].cols);\n      setData(ensureDataDims(s.data, SIZE_PRESETS[size].rows, SIZE_PRESETS[size].cols));\n      setSel(s.sel);\n      const f = s.data[s.sel.r]?.[s.sel.c] ?? \"\";\n      setFormula(f);\n      // Clear any stale external edit state when switching to sheet mode\n      setActiveExternalEdit(\"\");\n    } else {\n      // Clear external edit state when switching away from sheet mode\n      setActiveExternalEdit(\"\");\n    }\n    prevActiveRef.current = activeTab;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [activeTab]);\n\n  // Autosave current sheet while editing it\n  useEffect(() => {\n    if (!isSheetTab(activeTab)) return;\n    saveSheet(activeTab, { data, sel, size: sheetSize });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [data, sel, activeTab, sheetSize]);\n\n  // Global Save/Load (grid + report docs)\n  const GLOBAL_BASE = 'engineering-notebook:global';\n  const GLOBAL_LIST = `${GLOBAL_BASE}:saves`;\n  const GLOBAL_CURRENT = `${GLOBAL_BASE}:current`;\n  const saveKey = (name: string) => `${GLOBAL_BASE}:save:${name}`;\n  const listSaves = (): string[] => { try { const raw = localStorage.getItem(GLOBAL_LIST); if (!raw) return []; const arr = JSON.parse(raw); return Array.isArray(arr) ? arr.map(String) : []; } catch { return []; } };\n  const setSaves = (arr: string[]) => { try { localStorage.setItem(GLOBAL_LIST, JSON.stringify(Array.from(new Set(arr)))); } catch {} };\n\n  // Manage saves UI state\n  const [showSavesPanel, setShowSavesPanel] = useState(false);\n  const [selectedSaveName, setSelectedSaveName] = useState<string>(\"\");\n\n  const onSaveAll = () => {\n    try {\n      const currentName = localStorage.getItem(GLOBAL_CURRENT) || \"\";\n      const timeStamp = new Date().toISOString().replace('T',' ').slice(0,19);\n      let name = window.prompt('Save as (name):', currentName || timeStamp);\n      if (!name) return;\n      name = name.trim();\n      // Gather grid\n      const grid = { data, sel, activeSheetId: activeTab, tabs: tabsState };\n      // Gather report docs\n      const reportIds = tabsState.filter(t => t.kind === 'report').map(t => t.id);\n      const current = activeTab && getTabKind(activeTab) === 'report' ? activeTab : (reportIds[0] || 'default');\n      const docs: Record<string, any> = {};\n      const allIds = Array.from(new Set(['default', ...reportIds]));\n      for (const id of allIds) {\n        const raw = localStorage.getItem(`reportCanvas:doc:${id}`);\n        if (raw) docs[id] = JSON.parse(raw);\n      }\n      const payload = { grid, report: { docIds: allIds, current, docs } };\n      localStorage.setItem(saveKey(name), JSON.stringify(payload));\n      const saves = listSaves(); setSaves([name, ...saves]);\n      localStorage.setItem(GLOBAL_CURRENT, name);\n      setSelectedSaveName(name);\n      alert(`Saved as \"${name}\"`);\n    } catch (e) { alert('Save failed'); }\n  };\n\n  const loadSnapshot = (name: string) => {\n    const raw = localStorage.getItem(saveKey(name));\n    if (!raw) throw new Error('Snapshot not found');\n    const payload = JSON.parse(raw);\n    if (payload.grid) {\n      // Restore active sheet and its grid if available\n      const activeSheetId: string | undefined = payload.grid.activeSheetId;\n      if (activeSheetId && getTabKind(activeSheetId) === 'sheet') {\n        try { localStorage.setItem(sheetKey(activeSheetId), JSON.stringify({ data: payload.grid.data, sel: payload.grid.sel })); } catch {}\n        setActiveTab(activeSheetId);\n        setData(payload.grid.data); setSel(payload.grid.sel);\n        const fr = payload.grid.sel?.r ?? 0, fc = payload.grid.sel?.c ?? 0;\n        const f = payload.grid.data?.[fr]?.[fc] ?? \"\";\n        setFormula(f);\n      } else {\n        setData(payload.grid.data); setSel(payload.grid.sel);\n        const fr = payload.grid.sel?.r ?? 0, fc = payload.grid.sel?.c ?? 0;\n        const f = payload.grid.data?.[fr]?.[fc] ?? \"\";\n        setFormula(f);\n      }\n      // Optionally restore tabs if included\n      if (Array.isArray(payload.grid.tabs)) {\n        setTabsState(payload.grid.tabs);\n      }\n    }\n    if (payload.report) {\n      const { docIds, current: reportCurrent, docs } = payload.report;\n      if (Array.isArray(docIds)) localStorage.setItem('reportCanvas:docs', JSON.stringify(docIds));\n      if (typeof reportCurrent === 'string') localStorage.setItem('reportCanvas:current', reportCurrent);\n      if (docs && typeof docs === 'object') {\n        for (const [id, val] of Object.entries(docs)) {\n          localStorage.setItem(`reportCanvas:doc:${id}`, JSON.stringify(val));\n        }\n      }\n    }\n    localStorage.setItem(GLOBAL_CURRENT, name);\n    setReportVersion((v) => v + 1);\n  };\n\n  const onLoadAll = () => {\n    const saves = listSaves();\n    if (saves.length === 0) { alert('No saved snapshots'); return; }\n    const current = localStorage.getItem(GLOBAL_CURRENT) || saves[0];\n    setSelectedSaveName(current);\n    setShowSavesPanel(true);\n  };\n\n  const maybeInsertRef = (r: number, c: number, e: React.MouseEvent<HTMLTableCellElement>) => {\n    const fEl = formulaRef.current;\n    const addrStr = `${indexToCol(c)}${r + 1}`;\n    // If report is editing, insert into its active input\n    if (InsertBridge.hasInsertTarget()) {\n      e.preventDefault();\n      InsertBridge.insertText(addrStr);\n      // After inserting into report, ensure formula bar regains focus for sheet editing\n      // Use requestAnimationFrame for more reliable focus timing\n      requestAnimationFrame(() => {\n        // Only focus if we're still in sheet mode and no insert target is active\n        if (formulaRef.current && !InsertBridge.hasInsertTarget()) {\n          formulaRef.current.focus();\n        }\n      });\n      return true;\n    }\n    if (fEl && (document.activeElement === fEl || editing)) {\n      e.preventDefault();\n      const insertAddr = addrStr;\n      const start = fEl.selectionStart ?? formula.length;\n      const end = fEl.selectionEnd ?? formula.length;\n      const newVal = formula.slice(0, start) + insertAddr + formula.slice(end);\n      setFormula(newVal);\n      setData((prev) => { const copy = prev.map((rr) => [...rr]); copy[sel.r][sel.c] = newVal; return copy; });\n      setTimeout(() => { if (formulaRef.current) { formulaRef.current.selectionStart = formulaRef.current.selectionEnd = start + insertAddr.length; formulaRef.current.focus(); }}, 0);\n      return true;\n    }\n    return false;\n  };\n\n  const onFormulaKeyDown = (e: KBEvent<HTMLInputElement>) => {\n    if (e.key === \"Enter\") {\n      e.preventDefault();\n      // Commit is already reflected via onFormulaChange; just move selection\n      selectCell(sel.r + (e.shiftKey ? -1 : 1), sel.c);\n    } else if (e.key === \"Tab\") {\n      e.preventDefault();\n      selectCell(sel.r, sel.c + (e.shiftKey ? -1 : 1));\n    } else if (e.key === \"Escape\") {\n      e.preventDefault();\n      if (editing) {\n        const { r, c } = editing;\n        const original = originalEditValueRef.current;\n        setData((prev) => { const copy = prev.map((rowArr) => [...rowArr]); copy[r][c] = original; return copy; });\n        setFormula(original);\n        setEditing(null);\n        setTimeout(() => containerRef.current?.focus(), 0);\n      } else {\n        setTimeout(() => cellRefs.current[sel.r]?.[sel.c]?.focus(), 0);\n      }\n    }\n  };\n\n  // Ensure container gets focus initially so arrow keys work\n  useEffect(() => {\n    containerRef.current?.focus();\n  }, []);\n\n  const headerCellStyle: React.CSSProperties = {\n    background: \"#f3f3f3\",\n    color: \"#333\",\n    border: \"1px solid #4a4a4a\",\n    width: 100,\n  };\n\n  const headerDivStyle: React.CSSProperties = {\n    height: 28,\n    padding: 4,\n    boxSizing: \"border-box\",\n    textAlign: \"center\",\n    fontWeight: 600,\n    userSelect: \"none\",\n  };\n\n  useEffect(() => {\n    const onKey = (e: KeyboardEvent) => {\n      const target = e.target as HTMLElement | null;\n      const tag = target?.tagName?.toLowerCase();\n      const isEditable = !!(target && (tag === 'input' || tag === 'textarea' || target.isContentEditable));\n      if (isEditable) return; // allow native undo for text inputs\n      const combo = `${e.ctrlKey||e.metaKey?'Control+':''}${e.shiftKey?'Shift+':''}${e.altKey?'Alt+':''}${e.key.length===1?e.key.toLowerCase():e.key}`;\n      const norm = combo.replace('Control+Control+','Control+');\n      if (norm.toLowerCase() === (hotkeys.undo||'').toLowerCase()) {\n        e.preventDefault(); historyRef.current?.undoOnce();\n      } else if (norm.toLowerCase() === (hotkeys.save||'').toLowerCase()) {\n        e.preventDefault(); onSaveAll();\n      } else if (norm.toLowerCase() === (hotkeys.load||'').toLowerCase()) {\n        e.preventDefault(); onLoadAll();\n      }\n    };\n    window.addEventListener('keydown', onKey, true);\n    return () => window.removeEventListener('keydown', onKey, true);\n  }, [hotkeys]);\n\n  return (\n    <div>\n      <TopBar\n        addr={addr}\n        formula={(() => {\n          const t = InsertBridge.getInsertTarget();\n          if (t && t.kind === 'report' && t.getText) return t.getText();\n          return activeExternalEdit || formula;\n        })()}\n        onFormulaChange={(next) => {\n          const t = InsertBridge.getInsertTarget();\n          if (t && t.kind === 'report' && t.setText) {\n            t.setText(next);\n          } else {\n            onFormulaChange(next);\n          }\n        }}\n        formulaRef={formulaRef}\n        onFormulaKeyDown={(e) => {\n          const t = InsertBridge.getInsertTarget();\n          if (t && t.kind === 'report') {\n            if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); t.commit?.(); return; }\n            if (e.key === 'Escape') { e.preventDefault(); t.cancel?.(); return; }\n          }\n          onFormulaKeyDown?.(e);\n        }}\n        onJump={(jumpAddr) => { const parsed = parseAddress(jumpAddr, numRows, numCols); if (parsed) { selectCell(parsed.r, parsed.c); } }}\n        onSave={onSaveAll}\n        onLoad={onLoadAll}\n        onShowHotkeys={() => setHotkeysOpen(true)}\n        onUndo={() => historyRef.current?.undoOnce()}\n        onRedo={() => historyRef.current?.redoOnce()}\n        canUndo={!!historyRef.current?.canUndo?.()}\n        canRedo={!!historyRef.current?.canRedo?.()}\n        stickyInfo={(() => { const t = InsertBridge.getInsertTarget(); return (t && t.kind === 'report') ? { kind: 'report', boxId: (t as any).boxId || '—' } : null; })()}\n        onStickyCommit={() => { const t = InsertBridge.getInsertTarget(); t?.commit?.(); }}\n        onStickyCancel={() => { const t = InsertBridge.getInsertTarget(); t?.cancel?.(); }}\n      />\n\n      <div style={{ display: 'flex', alignItems: 'center' }}>\n        <Tabs\n          tabs={tabsState.map(t => ({ id: t.id, label: t.label }))}\n          active={activeTab}\n          onChange={(id) => setActiveTab(id)}\n          onDoubleClickTab={(id) => {\n            const name = window.prompt('Rename tab:', tabsState.find(t => t.id === id)?.label || id);\n            if (!name) return;\n            setTabsState(prev => prev.map(t => t.id === id ? { ...t, label: name } : t));\n          }}\n        />\n        <div style={{ marginLeft: 8, position: 'relative' }}>\n          <button onClick={() => {\n            const current = tabsState.find(t => t.id === activeTab);\n            if (!current) return;\n            const remaining = tabsState.filter(t => t.id !== activeTab);\n            if (remaining.length === 0) { alert('Cannot delete the last tab'); return; }\n            const ok = window.confirm(`Delete tab \"${current.label}\"?`);\n            if (!ok) return;\n            // Clean up persisted state for this tab\n            try {\n              if (current.kind === 'sheet') localStorage.removeItem(sheetKey(current.id));\n              else localStorage.removeItem(`reportCanvas:doc:${current.id}`);\n            } catch {}\n            setTabsState(remaining);\n            const idx = tabsState.findIndex(t => t.id === activeTab);\n            const nextIdx = Math.max(0, Math.min(idx, remaining.length - 1));\n            setActiveTab(remaining[nextIdx].id);\n          }} style={{ padding: '4px 8px', border: '1px solid #444', background: '#1f1f1f', color: '#efefef', marginRight: 6 }}>−</button>\n          <button onClick={() => {\n            const choice = window.prompt('Create which tab? (sheet/report)', 'sheet');\n            if (!choice) return; const kind = (choice.toLowerCase() === 'report') ? 'report' : 'sheet';\n            const base = kind === 'sheet' ? 'sheet' : 'report';\n            let i = 1; let id = `${base}${i}`; const existing = new Set(tabsState.map(t => t.id));\n            while (existing.has(id)) { i += 1; id = `${base}${i}`; }\n            const label = `${base[0].toUpperCase()}${base.slice(1)} ${i}`;\n            setTabsState(prev => [...prev, { id, label, kind }]);\n            setActiveTab(id);\n          }} style={{ padding: '4px 8px', border: '1px solid #444', background: '#1f1f1f', color: '#efefef' }}>＋</button>\n        </div>\n      </div>\n\n      <div className=\"main\" style={{ padding: \"1rem\", display: \"flex\", flexDirection: \"column\", minHeight: 0, width: \"100%\" }}>\n        {hotkeysOpen && (\n          <div style={{ alignSelf: 'center', position: 'fixed', top: 80, background: '#1b1b1b', border: '1px solid #444', borderRadius: 8, padding: 16, color: '#efefef', zIndex: 1000, minWidth: 420 }}>\n            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 8 }}>\n              <strong>Hotkeys & Tools</strong>\n              <button onClick={() => setHotkeysOpen(false)} style={{ padding: '2px 6px', border: '1px solid #555', background: '#2a2a2a', color: '#efefef' }}>Close</button>\n            </div>\n            <div style={{ display: 'grid', gridTemplateColumns: '1fr 160px', gap: 8 }}>\n              {[\n                { key: 'undo', label: 'Undo last edit (MVP)' },\n                { key: 'save', label: 'Save snapshot' },\n                { key: 'load', label: 'Load snapshot' },\n                { key: 'addBox', label: 'Report: Add box (when canvas focused)' },\n                { key: 'fullWidth', label: 'Report: Fit box to width' },\n                { key: 'reportSelect', label: 'Report: Switch to Select tool' },\n                { key: 'reportAdd', label: 'Report: Switch to Add tool' },\n              ].map((row) => (\n                <React.Fragment key={row.key}>\n                  <div style={{ alignSelf: 'center' }}>{row.label}</div>\n                  <input\n                    value={hotkeys[row.key] || ''}\n                    onChange={(e) => persistHotkeys({ ...hotkeys, [row.key]: e.target.value })}\n                    placeholder=\"e.g. Control+z\"\n                    style={{ background: '#111', color: '#efefef', border: '1px solid #555', padding: 4 }}\n                  />\n                </React.Fragment>\n              ))}\n            </div>\n            <div style={{ marginTop: 12, fontSize: 12, opacity: 0.85 }}>\n              Tip: Use names like Control, Shift, Alt with + and a key (example: Control+z). Case-insensitive.\n            </div>\n          </div>\n        )}\n        {showSavesPanel && (\n          <div style={{ alignSelf: 'flex-end', background: '#1b1b1b', border: '1px solid #444', borderRadius: 6, padding: 12, marginBottom: 8, display: 'flex', gap: 8, alignItems: 'center' }}>\n            <label>Snapshot:</label>\n            <select value={selectedSaveName} onChange={(e) => setSelectedSaveName(e.target.value)} style={{ background: '#1f1f1f', color: '#efefef', border: '1px solid #444', padding: '4px 8px' }}>\n              {listSaves().map((n) => (<option key={n} value={n}>{n}</option>))}\n            </select>\n            <button onClick={() => { try { loadSnapshot(selectedSaveName); setShowSavesPanel(false); } catch (e) { alert('Load failed'); } }} style={{ padding: '4px 8px', border: '1px solid #444', background: '#1f1f1f', color: '#efefef' }}>Load</button>\n            <button onClick={() => { if (!selectedSaveName) return; const ok = window.confirm(`Delete \"${selectedSaveName}\"?`); if (!ok) return; try { localStorage.removeItem(saveKey(selectedSaveName)); const rest = listSaves().filter((n) => n !== selectedSaveName); setSaves(rest); setSelectedSaveName(rest[0] || ''); } catch {} }} style={{ padding: '4px 8px', border: '1px solid #444', background: '#1f1f1f', color: '#efefef' }}>Delete</button>\n            <button onClick={() => setShowSavesPanel(false)} style={{ padding: '4px 8px', border: '1px solid #444', background: '#1f1f1f', color: '#efefef' }}>Close</button>\n          </div>\n        )}\n        {tabsState.find(t => t.id === activeTab)?.kind === 'sheet' ? (\n          <>\n            <div style={{ display: 'flex', justifyContent: 'flex-end', maxWidth: 1200, margin: '0 auto 8px', gap: 8 }}>\n              <label style={{ fontSize: 12, opacity: 0.9 }}>Grid size:</label>\n              <select\n                value={sheetSize}\n                onChange={(e) => {\n                  const next = (e.target.value as SheetSize);\n                  const dims = SIZE_PRESETS[next];\n                  setSheetSize(next);\n                  setNumRows(dims.rows); setNumCols(dims.cols);\n                  setData(prev => ensureDataDims(prev, dims.rows, dims.cols));\n                  // Adjust selection if out of bounds\n                  setSel(s => ({ r: Math.min(s.r, dims.rows - 1), c: Math.min(s.c, dims.cols - 1) }));\n                }}\n                style={{ background: '#1f1f1f', color: '#efefef', border: '1px solid #444', padding: '4px 8px' }}\n              >\n                <option value=\"small\">Small (200 x 26)</option>\n                <option value=\"medium\">Medium (1000 x 50)</option>\n                <option value=\"large\">Large (5000 x 80)</option>\n              </select>\n            </div>\n            <div ref={containerRef} tabIndex={0} onKeyDown={gridKeyDown} onScroll={onScroll} style={{ overflow: 'auto', border: '1px solid #4a4a4a', borderRadius: 4, background: '#fff', color: '#000', maxHeight: '70vh', margin: '0 auto', width: 'max-content' }}>\n              <table style={{ borderCollapse: \"collapse\", margin: 0 }}>\n                <tbody>\n                  {/* Column headers row */}\n                  <tr>\n                    {/* Top-left blank corner */}\n                    <th className=\"col-head\" style={{ position: 'sticky', top: 0, zIndex: 2, border: \"1px solid #4a4a4a\", width: 40, background: \"#f3f3f3\" }}>\n                      <div style={{ ...headerDivStyle, width: 40 }} />\n                    </th>\n                    {Array.from({ length: numCols }).map((_, c) => (\n                      <th key={`col-h-${c}`} className={`col-head ${sel.c === c ? \"active-head\" : \"\"}`} style={{ ...headerCellStyle, position: 'sticky', top: 0, zIndex: 1 }}>\n                        <div style={headerDivStyle}>{indexToCol(c)}</div>\n                      </th>\n                    ))}\n                  </tr>\n                  {/* Virtualized rows */}\n                  {isVirtualized ? (\n                    <>\n                      {startRow > 0 && (\n                        <tr aria-hidden=\"true\"><td style={{ height: startRow * rowHeight + 'px', padding: 0, border: 'none' }} colSpan={numCols + 1} /></tr>\n                      )}\n                      {data.slice(startRow, endRow).map((rowData, idx) => {\n                        const r = startRow + idx;\n                        return (\n                          <tr key={r}>\n                            <th className={`row-head ${sel.r === r ? \"active-head\" : \"\"}`} style={{ border: \"1px solid #4a4a4a\", width: 40, background: \"#f3f3f3\" }}>\n                              <div style={{ ...headerDivStyle, width: 40 }}>{r + 1}</div>\n                            </th>\n                            {rowData.map((raw, c) => {\n                              const isSel = sel.r === r && sel.c === c;\n                              const tdClass = [\n                                isSel ? \"selected\" : \"\",\n                                sel.r === r ? \"tint-row\" : \"\",\n                                sel.c === c ? \"tint-col\" : \"\",\n                              ].join(\" \").trim();\n                              return (\n                                <td\n                                  key={c}\n                                  className={tdClass}\n                                  style={{ border: \"1px solid #4a4a4a\", width: 100 }}\n                                  onMouseDown={(e) => { if (!maybeInsertRef(r, c, e)) { selectCell(r, c); } }}\n                                  onDoubleClick={() => enterEditMode(r, c)}\n                                >\n                                  <input\n                                    ref={(el) => {\n                                      if (!cellRefs.current[r]) cellRefs.current[r] = [];\n                                      cellRefs.current[r][c] = el;\n                                    }}\n                                    value={displayFor(r, c, raw)}\n                                    onChange={(e) => handleChange(r, c, e.target.value)}\n                                    onKeyDown={(e) => onInputKeyDown(e, r, c)}\n                                    onFocus={() => setSel({ r, c })}\n                                    readOnly={!isEditingCell(r, c)}\n                                    tabIndex={isEditingCell(r, c) ? 0 : -1}\n                                    style={{ width: \"100%\", height: 28, padding: 4, boxSizing: \"border-box\", background: \"#fff\", color: \"#000\", border: \"none\", outline: \"none\", pointerEvents: isEditingCell(r, c) ? \"auto\" : \"none\" }}\n                                  />\n                                </td>\n                              );\n                            })}\n                          </tr>\n                        );\n                      })}\n                      {endRow < numRows && (\n                        <tr aria-hidden=\"true\"><td style={{ height: (numRows - endRow) * rowHeight + 'px', padding: 0, border: 'none' }} colSpan={numCols + 1} /></tr>\n                      )}\n                    </>\n                  ) : (\n                    data.map((rowData, r) => (\n                      <tr key={r}>\n                        {/* Row header */}\n                        <th className={`row-head ${sel.r === r ? \"active-head\" : \"\"}`} style={{ border: \"1px solid #4a4a4a\", width: 40, background: \"#f3f3f3\" }}>\n                          <div style={{ ...headerDivStyle, width: 40 }}>{r + 1}</div>\n                        </th>\n                        {rowData.map((raw, c) => {\n                          const isSel = sel.r === r && sel.c === c;\n                          const tdClass = [\n                            isSel ? \"selected\" : \"\",\n                            sel.r === r ? \"tint-row\" : \"\",\n                            sel.c === c ? \"tint-col\" : \"\",\n                          ].join(\" \").trim();\n                          return (\n                            <td\n                              key={c}\n                              className={tdClass}\n                              style={{ border: \"1px solid #4a4a4a\", width: 100 }}\n                              onMouseDown={(e) => { if (!maybeInsertRef(r, c, e)) { selectCell(r, c); } }}\n                              onDoubleClick={() => enterEditMode(r, c)}\n                            >\n                              <input\n                                ref={(el) => { if (!cellRefs.current[r]) cellRefs.current[r] = []; cellRefs.current[r][c] = el; }}\n                                value={displayFor(r, c, raw)}\n                                onChange={(e) => handleChange(r, c, e.target.value)}\n                                onKeyDown={(e) => onInputKeyDown(e, r, c)}\n                                onFocus={() => setSel({ r, c })}\n                                readOnly={!isEditingCell(r, c)}\n                                tabIndex={isEditingCell(r, c) ? 0 : -1}\n                                style={{ width: \"100%\", height: 28, padding: 4, boxSizing: \"border-box\", background: \"#fff\", color: \"#000\", border: \"none\", outline: \"none\", pointerEvents: isEditingCell(r, c) ? \"auto\" : \"none\" }}\n                              />\n                            </td>\n                          );\n                        })}\n                      </tr>\n                    ))\n                  )}\n                </tbody>\n              </table>\n            </div>\n          </>\n        ) : (\n          <>\n            {import.meta.env.DEV && console.log('[BOOT] App: rendering ReportCanvas for tab', activeTab)}\n            <ReportCanvas\n            key={`${reportVersion}-${activeTab}`}\n            docId={activeTab}\n            getCellDisplay={getCellDisplay}\n            onActiveEditChange={(p) => setActiveExternalEdit(p?.value || \"\")}\n            reportHotkeys={{ selectTool: hotkeys.reportSelect || 'v', addTool: hotkeys.reportAdd || 'a' }}\n            history={historyProxy as any}\n            bindBoxesAccessor={(get, set) => {\n              boxesAccessorRef.current = { get, set };\n              if (historyRef.current) {\n                historyRef.current.setCtx(new AppCommandCtx(gridAccessor, {\n                  get: () => boxesAccessorRef.current ? boxesAccessorRef.current.get() : [],\n                  set: (next) => boxesAccessorRef.current?.set(next)\n                }));\n                // eslint-disable-next-line no-console\n                console.log('[BOOT] App: bindBoxesAccessor -> History setCtx');\n              }\n            }}\n          />\n          </>\n        )}\n\n        <div style={{ textAlign: \"center\", marginTop: 12, opacity: 0.9 }}>\n          <small>\n            Selected: {addr} • Value:{\" \"}\n            {(() => { const raw = data[sel.r][sel.c]; try { const val = evaluateWithGrid(data as string[][], raw); return String(val); } catch { return \"—\"; } })()}\n          </small>\n        </div>\n      </div>\n      {import.meta.env.DEV && (\n        <div style={{ position: 'fixed', bottom: 8, right: 8, background: '#222', color: '#eee', padding: '2px 6px', border: '1px solid #444', borderRadius: 4, fontSize: 12, zIndex: 9999 }}>\n          U:{historyBadge.u} R:{historyBadge.r}\n        </div>\n      )}\n    </div>\n  );\n}","size_bytes":43786},"src/index.tsx":{"content":"import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport App from './App'\n\nReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n)","size_bytes":223},"README.md":{"content":"# Engineering Notebook (React + TypeScript + Vite)\n\nThis app provides a minimal spreadsheet (Sheet) and a unit-aware report canvas (Report) with shared undo/redo.\n\n## Quick start\n\n```bash\nnpm i\nnpm run dev\nnpm run lint\nnpm run build\nnpx vitest run\n```\n\n## Contributing notes\n\n- A1 helpers are centralized in `src/referencing/a1.ts`. Use `indexToCol` and `parseAddress` from there.\n- Grid evaluator is canonical at `src/engine/eval.ts`. Other modules import from it.\n- Cycle detection: circular references throw `#CYCLE!` to avoid infinite recursion. Tests cover this behavior.\n- Parser fallback: the parser in `src/parser/*` supports +/− only. STAR/SLASH intentionally throw `__MULT_DIV_FALLBACK__` to signal higher-level fallback.\n\n## Tests\n\n- Unit tests rely on Vitest. Run all tests: `npx vitest run`.\n- Coverage includes history parity, evaluator (including cycles), A1 helpers, parser formatting/fallback, and report model (defs/units/VLOOKUP basics).\n\n## ESLint configuration\n\nCurrently, two official plugins are available:\n\n- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh\n- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh\n\n## Expanding the ESLint configuration\n\nIf you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:\n\n```js\nexport default tseslint.config([\n  globalIgnores(['dist']),\n  {\n    files: ['**/*.{ts,tsx}'],\n    extends: [\n      // Other configs...\n\n      // Remove tseslint.configs.recommended and replace with this\n      ...tseslint.configs.recommendedTypeChecked,\n      // Alternatively, use this for stricter rules\n      ...tseslint.configs.strictTypeChecked,\n      // Optionally, add this for stylistic rules\n      ...tseslint.configs.stylisticTypeChecked,\n\n      // Other configs...\n    ],\n    languageOptions: {\n      parserOptions: {\n        project: ['./tsconfig.node.json', './tsconfig.app.json'],\n        tsconfigRootDir: import.meta.dirname,\n      },\n      // other options...\n    },\n  },\n])\n```\n\nYou can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:\n\n```js\n// eslint.config.js\nimport reactX from 'eslint-plugin-react-x'\nimport reactDom from 'eslint-plugin-react-dom'\n\nexport default tseslint.config([\n  globalIgnores(['dist']),\n  {\n    files: ['**/*.{ts,tsx}'],\n    extends: [\n      // Other configs...\n      // Enable lint rules for React\n      reactX.configs['recommended-typescript'],\n      // Enable lint rules for React DOM\n      reactDom.configs.recommended,\n    ],\n    languageOptions: {\n      parserOptions: {\n        project: ['./tsconfig.node.json', './tsconfig.app.json'],\n        tsconfigRootDir: import.meta.dirname,\n      },\n      // other options...\n    },\n  },\n])\n```\n","size_bytes":3124},"eslint.config.js":{"content":"import js from '@eslint/js'\nimport globals from 'globals'\nimport reactHooks from 'eslint-plugin-react-hooks'\nimport reactRefresh from 'eslint-plugin-react-refresh'\nimport tseslint from 'typescript-eslint'\nimport { globalIgnores } from 'eslint/config'\n\nexport default tseslint.config([\n  globalIgnores(['dist']),\n  {\n    files: ['**/*.{ts,tsx}'],\n    extends: [\n      js.configs.recommended,\n      tseslint.configs.recommended,\n      reactHooks.configs['recommended-latest'],\n      reactRefresh.configs.vite,\n    ],\n    languageOptions: {\n      ecmaVersion: 2020,\n      globals: globals.browser,\n    },\n  },\n])\n","size_bytes":610},"replit.md":{"content":"# Engineering Notebook\n\n## Overview\nThe Engineering Notebook is a web-based calculation and documentation tool designed for engineers. It provides unit-aware calculations, spreadsheet functionality, and visual report creation capabilities.\n\n## Project Architecture\n- **Framework**: React 19.1.1 + TypeScript + Vite 7.1.5\n- **Development Server**: Runs on port 5000 (0.0.0.0:5000)\n- **Storage**: Uses browser localStorage for persistence\n\n## Core Features\n\n### 1. Spreadsheet (Sheet Tab)\n- Traditional spreadsheet with A1-style cell referencing\n- Formula evaluation supporting +, -, *, / operations\n- Cell reference support (e.g., =A1+B2)\n- Cycle detection to prevent infinite loops\n- Copy/paste functionality\n- Keyboard navigation (arrows, tab, enter)\n- Undo/redo support\n\n### 2. Unit-Aware Report Canvas (Report Tab)\n- Visual canvas for creating calculation boxes\n- Drag-and-drop, resize, and positioning of elements\n- Unit-aware calculations (length, force, pressure, time)\n- Automatic unit conversions (imperial/metric)\n- Mathematical expression rendering\n- Layout persistence\n\n### 3. History Management\n- Comprehensive undo/redo across all features\n- Transaction-based operations\n- Command pattern implementation\n\n### 4. Notebook Feature\n- Text and math block creation\n- Mathematical notation support\n- Persistent storage\n\n## Project Structure\n```\nsrc/\n├── components/          # UI components (TopBar, Tabs, etc.)\n├── engine/             # Core calculation engine\n│   ├── eval.ts         # Formula evaluation\n│   ├── formatUnits.ts  # Unit conversion system\n│   └── unitPrefs.ts    # Unit preferences\n├── frames/             # Main application views\n│   ├── ReportCanvas/   # Visual report creation\n│   └── ReportPad/      # Report calculation logic\n├── history/            # Undo/redo system\n│   ├── commands/       # Command implementations\n│   └── History.ts      # Core history manager\n├── parser/             # Expression parsing\n├── referencing/        # A1-style cell references\n└── App.tsx             # Main application component\n```\n\n## Development Commands\n- `npm run dev` - Start development server\n- `npm run build` - Build for production\n- `npm run preview` - Preview production build\n- `npm run lint` - Run ESLint\n\n## Recent Changes (September 14, 2025)\n- Reorganized file structure from nested `engineering-notebook/` directory to root\n- Configured Vite to serve on 0.0.0.0:5000 for proper Replit hosting\n- Set up development workflow with automatic restart\n- Resolved all TypeScript LSP diagnostics\n\n## Current State\n✅ Application is fully functional and running\n✅ Development server configured correctly\n✅ All dependencies installed and working\n✅ TypeScript compilation clean\n✅ Ready for development and testing\n\n## User Preferences\n- Prefers organized, structured code\n- Focus on engineering calculation accuracy\n- Unit-aware calculations are critical\n- Visual documentation capability important","size_bytes":3027},"src/components/ErrorBoundary.tsx":{"content":"import React from 'react';\r\n\r\ntype Props = { children: React.ReactNode };\r\ntype State = { error: Error | null };\r\n\r\nexport default class ErrorBoundary extends React.Component<Props, State> {\r\n  constructor(props: Props) {\r\n    super(props);\r\n    this.state = { error: null };\r\n  }\r\n\r\n  static getDerivedStateFromError(error: Error) {\r\n    return { error };\r\n  }\r\n\r\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {\r\n    // eslint-disable-next-line no-console\r\n    console.error('ErrorBoundary caught error:', error, errorInfo);\r\n  }\r\n\r\n  render(): React.ReactNode {\r\n    if (this.state.error) {\r\n      return (\r\n        <div style={{ padding: 16 }}>\r\n          <h3>Something went wrong.</h3>\r\n          <pre style={{ whiteSpace: 'pre-wrap' }}>{String(this.state.error?.message || this.state.error)}</pre>\r\n        </div>\r\n      );\r\n    }\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\n\r\n","size_bytes":904},"src/components/FormulaBar.tsx":{"content":"import React, { forwardRef, useImperativeHandle, useRef, useEffect } from \"react\";\r\n\r\ntype Props = {\r\n  value: string;\r\n  onChange: (next: string) => void;\r\n  onKeyDown?: React.KeyboardEventHandler<HTMLInputElement>;\r\n  stickyInfo?: { kind: 'report'; boxId: string } | null;\r\n  onStickyCommit?: () => void;\r\n  onStickyCancel?: () => void;\r\n};\r\n\r\nexport type FormulaBarHandle = {\r\n  insertAtCursor: (text: string) => void;\r\n  getSelection: () => { start: number; end: number };\r\n};\r\n\r\nconst FormulaBar = forwardRef<HTMLInputElement, Props>(({ value, onChange, onKeyDown, stickyInfo, onStickyCommit, onStickyCancel }, ref) => {\r\n  const inputRef = useRef<HTMLInputElement | null>(null);\r\n\r\n  useImperativeHandle(ref, () => inputRef.current as HTMLInputElement);\r\n\r\n  const insertAtCursor = (_text: string) => { /* unused imperative handle in current usage */ };\r\n\r\n  const getSelection = () => ({ start: 0, end: 0 });\r\n\r\n  const handleKeyDown: React.KeyboardEventHandler<HTMLInputElement> = (e) => {\r\n    if (stickyInfo && e.key === 'Enter' && !e.shiftKey) {\r\n      e.preventDefault(); onStickyCommit?.(); return;\r\n    }\r\n    if (stickyInfo && e.key === 'Escape') {\r\n      e.preventDefault(); onStickyCancel?.(); return;\r\n    }\r\n    if (onKeyDown) onKeyDown(e);\r\n  };\r\n\r\n  useEffect(() => {\r\n    // keep inputRef synced\r\n  }, [value]);\r\n\r\n  return (\r\n    <div style={{ display: 'flex', alignItems: 'center', gap: 8, flex: 1 }}>\r\n      {stickyInfo && (\r\n        <span style={{ fontSize: 12, color: '#ddd', background: '#333', padding: '2px 6px', borderRadius: 4 }}>\r\n          Editing: Report • {stickyInfo.boxId} <button onClick={onStickyCancel} style={{ marginLeft: 6, padding: '0 4px' }}>✕</button>\r\n        </span>\r\n      )}\r\n      <input\r\n        ref={inputRef}\r\n        value={value}\r\n        onChange={(e) => onChange(e.target.value)}\r\n        onKeyDown={handleKeyDown}\r\n        style={{\r\n          flex: 1,\r\n          height: 28,\r\n          padding: 4,\r\n          boxSizing: \"border-box\",\r\n          background: \"#ffffff\",\r\n          color: \"#000000\",\r\n          border: \"1px solid #4a4a4a\",\r\n          outline: \"none\",\r\n        }}\r\n      />\r\n      {stickyInfo && (\r\n        <button onClick={onStickyCommit} style={{ padding: '4px 8px', border: '1px solid #444', background: '#1f1f1f', color: '#efefef' }}>✔</button>\r\n      )}\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default FormulaBar;","size_bytes":2390},"src/components/NameBox.tsx":{"content":"import { useEffect, useState } from \"react\";\r\n\r\ntype Props = {\r\n  addr: string;\r\n  onJump?: (addr: string) => void;\r\n};\r\n\r\nexport default function NameBox({ addr, onJump }: Props) {\r\n  const [value, setValue] = useState(addr);\r\n\r\n  useEffect(() => {\r\n    setValue(addr);\r\n  }, [addr]);\r\n\r\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\r\n    if (e.key === \"Enter\" && onJump) {\r\n      const trimmed = value.trim().toUpperCase();\r\n      if (/^[A-Z]+[1-9][0-9]*$/.test(trimmed)) {\r\n        onJump(trimmed);\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <input\r\n      value={value}\r\n      onChange={(e) => setValue(e.target.value)}\r\n      onKeyDown={handleKeyDown}\r\n      style={{\r\n        width: 80,\r\n        height: 28,\r\n        padding: 4,\r\n        boxSizing: \"border-box\",\r\n        background: \"#fff\",\r\n        color: \"#000\",\r\n        border: \"1px solid #4a4a4a\",\r\n        outline: \"none\",\r\n        textAlign: \"center\",\r\n        fontWeight: 600,\r\n      }}\r\n    />\r\n  );\r\n}\r\n  ","size_bytes":995},"src/components/Tabs.tsx":{"content":"import React from \"react\";\r\n\r\nexport type TabItem = { id: string; label: string };\r\n\r\ntype TabsProps = {\r\n  tabs: TabItem[];\r\n  active: string;\r\n  onChange: (id: string) => void;\r\n  onDoubleClickTab?: (id: string) => void;\r\n};\r\n\r\nexport default function Tabs({ tabs, active, onChange, onDoubleClickTab }: TabsProps) {\r\n  return (\r\n    <div style={{ display: \"flex\", gap: 6, alignItems: \"flex-end\", padding: \"8px 12px\", borderBottom: \"1px solid #444\", maxWidth: 1200, margin: \"0 auto\" }} role=\"tablist\" aria-label=\"Frames\">\r\n      {tabs.map((t) => {\r\n        const isActive = t.id === active;\r\n        return (\r\n          <button\r\n            key={t.id}\r\n            role=\"tab\"\r\n            aria-selected={isActive}\r\n            onClick={() => onChange(t.id)}\r\n            onDoubleClick={() => onDoubleClickTab?.(t.id)}\r\n            style={{\r\n              padding: \"6px 12px\",\r\n              border: \"1px solid #4a4a4a\",\r\n              background: isActive ? \"#2b2b2b\" : \"#1f1f1f\",\r\n              color: \"#efefef\",\r\n              cursor: \"pointer\",\r\n              borderTopLeftRadius: 6,\r\n              borderTopRightRadius: 6,\r\n              boxShadow: isActive ? \"0 1px 2px rgba(0,0,0,0.3)\" : undefined,\r\n            }}\r\n          >\r\n            {t.label}\r\n          </button>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n} ","size_bytes":1323},"src/components/TopBar.tsx":{"content":"import NameBox from \"./NameBox\";\r\nimport FormulaBar from \"./FormulaBar\";\r\n\r\ntype Props = {\r\n  addr: string;\r\n  formula: string;\r\n  onFormulaChange: (next: string) => void;\r\n  formulaRef: React.RefObject<HTMLInputElement> | React.MutableRefObject<HTMLInputElement | null>;\r\n  onFormulaKeyDown?: React.KeyboardEventHandler<HTMLInputElement>;\r\n  onJump?: (addr: string) => void;\r\n  onSave?: () => void;\r\n  onLoad?: () => void;\r\n  onShowHotkeys?: () => void;\r\n  onUndo?: () => void;\r\n  onRedo?: () => void;\r\n  canUndo?: boolean;\r\n  canRedo?: boolean;\r\n  stickyInfo?: { kind: 'report'; boxId: string } | null;\r\n  onStickyCommit?: () => void;\r\n  onStickyCancel?: () => void;\r\n};\r\n\r\nexport default function TopBar({ addr, formula, onFormulaChange, formulaRef, onFormulaKeyDown, onJump, onSave, onLoad, onShowHotkeys, onUndo, onRedo, canUndo, canRedo, stickyInfo, onStickyCommit, onStickyCancel }: Props) {\r\n  return (\r\n    <div style={{ display: \"flex\", gap: 8, alignItems: \"center\", padding: \"8px 12px\", borderBottom: \"1px solid #444\", maxWidth: 1200, margin: \"0 auto\" }}>\r\n      <NameBox addr={addr} onJump={onJump} />\r\n      <FormulaBar ref={formulaRef} value={formula} onChange={onFormulaChange} onKeyDown={onFormulaKeyDown} stickyInfo={stickyInfo ?? undefined} onStickyCommit={onStickyCommit} onStickyCancel={onStickyCancel} />\r\n      <div style={{ marginLeft: \"auto\", display: \"flex\", gap: 8 }}>\r\n        {onUndo && <button onClick={onUndo} disabled={canUndo === false} title=\"Undo (Ctrl+Z)\" style={{ padding: \"4px 8px\", border: \"1px solid #444\", background: \"#1f1f1f\", color: \"#efefef\", opacity: canUndo === false ? 0.5 : 1 }}>Undo</button>}\r\n        {onRedo && <button onClick={onRedo} disabled={canRedo === false} title=\"Redo (Ctrl+Shift+Z)\" style={{ padding: \"4px 8px\", border: \"1px solid #444\", background: \"#1f1f1f\", color: \"#efefef\", opacity: canRedo === false ? 0.5 : 1 }}>Redo</button>}\r\n        {onSave && <button onClick={onSave} style={{ padding: \"4px 8px\", border: \"1px solid #444\", background: \"#1f1f1f\", color: \"#efefef\" }}>Save</button>}\r\n        {onLoad && <button onClick={onLoad} style={{ padding: \"4px 8px\", border: \"1px solid #444\", background: \"#1f1f1f\", color: \"#efefef\" }}>Load</button>}\r\n        {onShowHotkeys && <button onClick={onShowHotkeys} title=\"Hotkeys and commands\" style={{ padding: \"4px 8px\", border: \"1px solid #444\", background: \"#1f1f1f\", color: \"#efefef\" }}>Hotkeys</button>}\r\n      </div>\r\n    </div>\r\n  );\r\n}","size_bytes":2449},"src/debug/CrashOverlay.ts":{"content":"/*\r\n  DEV-ONLY CrashOverlay\r\n  - Disable by removing installCrashOverlay() in main.tsx or building with DEV=false\r\n  - No side effects on import. Call installCrashOverlay() to wire it up.\r\n*/\r\n\r\ntype LogEntry = {\r\n  ts: number;\r\n  level: 'log' | 'warn' | 'error';\r\n  args: any[];\r\n};\r\n\r\ntype BootMark = { ts: number; label: string };\r\n\r\nlet ringBuffer: LogEntry[] = [];\r\nlet bootMarks: BootMark[] = [];\r\nlet overlayEl: HTMLDivElement | null = null;\r\nlet overlayPreEl: HTMLPreElement | null = null;\r\nlet mounted = false;\r\nlet timeoutId: number | null = null;\r\nlet patched = false;\r\n// let warnedPreReady = false;\r\n\r\nfunction ensureOverlay() {\r\n  if (overlayEl) return;\r\n  overlayEl = document.createElement('div');\r\n  overlayEl.id = 'crash-overlay';\r\n  overlayEl.style.position = 'fixed';\r\n  overlayEl.style.top = '8px';\r\n  overlayEl.style.right = '8px';\r\n  overlayEl.style.maxWidth = '50vw';\r\n  overlayEl.style.maxHeight = '70vh';\r\n  overlayEl.style.overflow = 'auto';\r\n  overlayEl.style.zIndex = '2147483647';\r\n  overlayEl.style.background = 'rgba(0,0,0,0.85)';\r\n  overlayEl.style.color = '#ffe8e8';\r\n  overlayEl.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';\r\n  overlayEl.style.fontSize = '12px';\r\n  overlayEl.style.padding = '10px';\r\n  overlayEl.style.border = '1px solid #ff5555';\r\n  overlayEl.style.borderRadius = '6px';\r\n\r\n  const header = document.createElement('div');\r\n  header.style.display = 'flex';\r\n  header.style.justifyContent = 'space-between';\r\n  header.style.alignItems = 'center';\r\n  header.style.marginBottom = '6px';\r\n  const title = document.createElement('strong');\r\n  title.textContent = 'Crash Overlay (DEV)';\r\n  const btns = document.createElement('div');\r\n  const hideBtn = document.createElement('button');\r\n  hideBtn.textContent = 'Hide';\r\n  hideBtn.style.marginLeft = '6px';\r\n  hideBtn.onclick = () => hide();\r\n  btns.appendChild(hideBtn);\r\n  header.appendChild(title); header.appendChild(btns);\r\n\r\n  overlayPreEl = document.createElement('pre');\r\n  overlayPreEl.style.margin = '0';\r\n  overlayPreEl.style.whiteSpace = 'pre-wrap';\r\n\r\n  overlayEl.appendChild(header);\r\n  overlayEl.appendChild(overlayPreEl);\r\n  document.body.appendChild(overlayEl);\r\n}\r\n\r\nfunction dumpBuffer(extra?: string) {\r\n  if (!overlayPreEl) return;\r\n  const lines: string[] = [];\r\n  if (extra) lines.push(extra, '');\r\n  const last = ringBuffer.slice(-200);\r\n  for (const e of last) {\r\n    const ts = new Date(e.ts).toISOString().slice(11, 23);\r\n    const msg = e.args.map(stringify).join(' ');\r\n    lines.push(`[${ts}] ${e.level.toUpperCase()}: ${msg}`);\r\n  }\r\n  const marks = getBootReport();\r\n  if (marks.marks.length) {\r\n    lines.push('', 'Boot marks:');\r\n    const t0 = marks.marks[0].ts;\r\n    for (const m of marks.marks) {\r\n      lines.push(` +${(m.ts - t0).toString().padStart(4)}ms ${m.label}`);\r\n    }\r\n  }\r\n  overlayPreEl.textContent = lines.join('\\n');\r\n}\r\n\r\nfunction show(err?: any, ctx?: any) {\r\n  ensureOverlay();\r\n  const parts: string[] = [];\r\n  if (err) parts.push('Error:', stringify(err));\r\n  if (ctx) parts.push('Context:', stringify(ctx));\r\n  dumpBuffer(parts.join('\\n'));\r\n}\r\n\r\nfunction hide() {\r\n  if (overlayEl && overlayEl.parentNode) overlayEl.parentNode.removeChild(overlayEl);\r\n  overlayEl = null; overlayPreEl = null;\r\n}\r\n\r\nfunction pushLog(level: LogEntry['level'], args: any[]) {\r\n  ringBuffer.push({ ts: Date.now(), level, args });\r\n  if (ringBuffer.length > 200) ringBuffer.shift();\r\n}\r\n\r\nfunction stringify(x: any): string {\r\n  if (x instanceof Error) return `${x.name}: ${x.message}\\n${x.stack || ''}`;\r\n  try { return typeof x === 'string' ? x : JSON.stringify(x); }\r\n  catch { return String(x); }\r\n}\r\n\r\nexport function installCrashOverlay(opts?: { mountTimeoutMs?: number; showOnWarn?: boolean }) {\r\n  if (!import.meta.env.DEV) return;\r\n  const mountTimeoutMs = opts?.mountTimeoutMs ?? 2000;\r\n  const showOnWarn = opts?.showOnWarn ?? false;\r\n\r\n  // Patch console\r\n  if (!patched) {\r\n    patched = true;\r\n    const orig = { error: console.error, warn: console.warn, log: console.log };\r\n    console.error = (...args: any[]) => { pushLog('error', args); orig.error.apply(console, args); show(args[0]); };\r\n    console.warn = (...args: any[]) => { pushLog('warn', args); orig.warn.apply(console, args); if (showOnWarn) show(args[0]); };\r\n    console.log = (...args: any[]) => { pushLog('log', args); orig.log.apply(console, args); };\r\n  }\r\n\r\n  // Resource and runtime errors\r\n  const onResourceError = (e: Event) => {\r\n    const target = e.target as any;\r\n    const tag = target?.tagName || 'unknown';\r\n    const src = target?.src || target?.href || '';\r\n    show(`Resource load error: <${tag.toLowerCase()}> ${src}`);\r\n  };\r\n  const onUnhandled = (ev: PromiseRejectionEvent) => {\r\n    show('Unhandled rejection', ev.reason);\r\n  };\r\n  const onWindowError = (msg: string | Event, src?: string, line?: number, col?: number, err?: Error) => {\r\n    show('window.onerror', { msg, src, line, col, err });\r\n  };\r\n  window.addEventListener('error', onResourceError, true);\r\n  window.addEventListener('unhandledrejection', onUnhandled);\r\n  window.onerror = onWindowError as any;\r\n\r\n  // Mount watchdog\r\n  if (timeoutId) { clearTimeout(timeoutId); }\r\n  timeoutId = window.setTimeout(() => {\r\n    if (!mounted) {\r\n      const report = getBootReport();\r\n      show('App did not mount in time', report);\r\n    }\r\n  }, mountTimeoutMs);\r\n\r\n  // Testing helper\r\n  (window as any).__crash = (msg = 'manual crash') => { throw new Error(msg); };\r\n  (window as any).__recordBoot = (label: string) => recordBootMark(label);\r\n}\r\n\r\nexport function signalAppMounted() {\r\n  mounted = true;\r\n  if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; }\r\n}\r\n\r\nexport function recordBootMark(label: string) {\r\n  bootMarks.push({ ts: Date.now(), label });\r\n  if (bootMarks.length > 200) bootMarks.shift();\r\n}\r\n\r\nexport function getBootReport(): { marks: BootMark[]; last?: BootMark; duration?: number } {\r\n  const marks = bootMarks.slice();\r\n  const last = marks[marks.length - 1];\r\n  const duration = marks.length >= 2 ? (marks[marks.length - 1].ts - marks[0].ts) : undefined;\r\n  return { marks, last, duration };\r\n}\r\n\r\n\r\n","size_bytes":6165},"src/engine/eval.test.ts":{"content":"import { describe, it, expect } from 'vitest';\r\nimport { evaluate } from './eval';\r\n\r\ndescribe('engine/eval', () => {\r\n  it('evaluates numbers and simple formulas', () => {\r\n    const grid = [ ['1','2'], ['=A1+B1',''] ];\r\n    expect(evaluate(grid, grid[0][0])).toBe(1);\r\n    expect(evaluate(grid, grid[1][0])).toBe(3);\r\n  });\r\n\r\n  it('detects simple 2-cell cycles', () => {\r\n    const grid = [ ['=B1','=A1'] ];\r\n    expect(() => evaluate(grid, grid[0][0])).toThrow('#CYCLE!');\r\n    expect(() => evaluate(grid, grid[0][1])).toThrow('#CYCLE!');\r\n  });\r\n\r\n  it('detects longer cycles', () => {\r\n    const grid = [ ['=B1','=C1','=A1'] ];\r\n    expect(() => evaluate(grid, grid[0][0])).toThrow('#CYCLE!');\r\n  });\r\n});\r\n\r\n\r\n","size_bytes":717},"src/engine/graph.ts":{"content":"export { evaluate } from './eval';\r\nexport type { Grid } from './eval';\r\n\r\nexport type NodeId = string;\r\n\r\nexport type GraphNode = {\r\n  id: NodeId;\r\n  inputs: NodeId[];\r\n  outputs: NodeId[];\r\n};\r\n\r\nexport type Graph = {\r\n  addNode: (id: NodeId) => void;\r\n  removeNode: (id: NodeId) => void;\r\n  addEdge: (from: NodeId, to: NodeId) => void;\r\n  removeEdge: (from: NodeId, to: NodeId) => void;\r\n  getDependents: (id: NodeId) => NodeId[];\r\n  getDependencies: (id: NodeId) => NodeId[];\r\n};\r\n\r\nexport function createGraph(): Graph {\r\n  const edges = new Map<NodeId, Set<NodeId>>();\r\n  const reverse = new Map<NodeId, Set<NodeId>>();\r\n\r\n  const ensure = (id: NodeId) => {\r\n    if (!edges.has(id)) edges.set(id, new Set());\r\n    if (!reverse.has(id)) reverse.set(id, new Set());\r\n  };\r\n\r\n  return {\r\n    addNode(id) { ensure(id); },\r\n    removeNode(id) { edges.delete(id); reverse.delete(id); for (const [k, set] of edges) set.delete(id); for (const [k, set] of reverse) set.delete(id); },\r\n    addEdge(from, to) { ensure(from); ensure(to); edges.get(from)!.add(to); reverse.get(to)!.add(from); },\r\n    removeEdge(from, to) { edges.get(from)?.delete(to); reverse.get(to)?.delete(from); },\r\n    getDependents(id) { return Array.from(reverse.get(id) ?? []); },\r\n    getDependencies(id) { return Array.from(edges.get(id) ?? []); },\r\n  };\r\n}\r\n","size_bytes":1330},"src/engine/notes.ts":{"content":"import { evaluate as evaluateUnified } from '../unified_parser';\n\nexport type Grid = string[][];\n\nexport function evaluate(grid: Grid, raw: string): number {\n  const s = raw.trim();\n  \n  // Handle non-formula numbers directly  \n  if (!s.startsWith(\"=\")) {\n    const n = Number(s);\n    if (Number.isFinite(n)) return n;\n    throw new Error(\"Not a formula/number\");\n  }\n  \n  // Strip leading '=' and delegate to unified parser\n  const expr = s.slice(1);\n  const context = {\n    getCell: (ref: string) => {\n      // Extract cell value from grid using A1 reference\n      const match = ref.match(/^([A-Z]+)([1-9][0-9]*)$/);\n      if (match) {\n        const col = match[1];\n        const row = parseInt(match[2], 10) - 1;\n        let c = 0;\n        for (let i = 0; i < col.length; i++) {\n          c = c * 26 + (col.charCodeAt(i) - 64);\n        }\n        c -= 1;\n        return grid[row]?.[c] ?? \"0\";\n      }\n      return \"0\";\n    }\n  };\n  \n  try {\n    const result = evaluateUnified(expr, context);\n    return result.valueSI; // Return numeric value for compatibility\n  } catch (error) {\n    throw new Error(`Evaluation error: ${error}`);\n  }\n}","size_bytes":1139},"src/engine/steps.ts":{"content":"import { parse as parseUnified, evaluate as evaluateUnified, formatQuantity } from '../unified_parser';\n\nexport type StepDoc = {\n  equationLaTeX?: string;\n  inputs: Array<{ name: string; display: string; source?: string }>;\n  substitutionLaTeX?: string;\n  result?: { display: string; unit?: string };\n  notes?: string[];\n  // New: structured fraction info for nicer rendering without KaTeX\n  fraction?: { numerator: string; denominator: string };\n  substitutionFraction?: { numerator: string; denominator: string };\n  numericResult?: number;\n};\n\nexport function build(expr: string, ctx: { getCellDisplay: (r: number, c: number) => string; resolveName?: (name: string) => string | undefined }): StepDoc {\n  // Use unified parser exclusively - no more duplicate parsing logic\n  const parsed = parseUnified(expr);\n  \n  // Extract cell references from expression using unified parser approach\n  const cellMatches = expr.match(/\\b([A-Z]+)([1-9][0-9]*)\\b/g) || [];\n  const refs: Array<{ label: string; r: number; c: number }> = [];\n  \n  for (const cellRef of cellMatches) {\n    const match = cellRef.match(/^([A-Z]+)([1-9][0-9]*)$/);\n    if (match) {\n      const col = match[1];\n      const row = parseInt(match[2], 10) - 1;\n      let c = 0;\n      for (let i = 0; i < col.length; i++) {\n        c = c * 26 + (col.charCodeAt(i) - 64);\n      }\n      c -= 1;\n      refs.push({ label: cellRef, r: row, c });\n    }\n  }\n  \n  const inputs = refs.map((r) => ({ name: r.label, display: ctx.getCellDisplay(r.r, r.c), source: r.label }));\n\n  // Try to evaluate using unified parser\n  try {\n    const context = {\n      getCell: (ref: string) => {\n        const cellMatch = ref.match(/^([A-Z]+)([1-9][0-9]*)$/);\n        if (cellMatch) {\n          const col = cellMatch[1];\n          const row = parseInt(cellMatch[2], 10) - 1;\n          let c = 0;\n          for (let i = 0; i < col.length; i++) {\n            c = c * 26 + (col.charCodeAt(i) - 64);\n          }\n          c -= 1;\n          return ctx.getCellDisplay(row, c);\n        }\n        return \"0\";\n      },\n      getVariable: ctx.resolveName ? (name: string) => {\n        const val = ctx.resolveName!(name);\n        if (val && !isNaN(parseFloat(val))) {\n          return { value: parseFloat(val), valueSI: parseFloat(val), dims: { L: 0, M: 0, T: 0, F: 0 } };\n        }\n        return undefined;\n      } : undefined\n    };\n    \n    const result = evaluateUnified(expr, context);\n    const resultDisplay = formatQuantity(result);\n    \n    // Check if this looks like a simple fraction for LaTeX rendering\n    const fractionMatch = expr.match(/^\\s*([A-Za-z][A-Za-z0-9_]*|[A-Z]+[1-9][0-9]*|\\d+(?:\\.\\d+)?)\\s*\\/\\s*([A-Za-z][A-Za-z0-9_]*|[A-Z]+[1-9][0-9]*|\\d+(?:\\.\\d+)?)\\s*$/);\n    if (fractionMatch) {\n      const left = fractionMatch[1];\n      const right = fractionMatch[2];\n      \n      // Get substituted values for display\n      const leftDisplay = refs.find(r => r.label === left) ? ctx.getCellDisplay(refs.find(r => r.label === left)!.r, refs.find(r => r.label === left)!.c) : left;\n      const rightDisplay = refs.find(r => r.label === right) ? ctx.getCellDisplay(refs.find(r => r.label === right)!.r, refs.find(r => r.label === right)!.c) : right;\n      \n      return {\n        equationLaTeX: `\\\\frac{${left}}{${right}}`,\n        substitutionLaTeX: `\\\\frac{${leftDisplay}}{${rightDisplay}}`,\n        inputs,\n        fraction: { numerator: left, denominator: right },\n        substitutionFraction: { numerator: leftDisplay, denominator: rightDisplay },\n        numericResult: result.value,\n        result: { display: resultDisplay, unit: result.unit },\n      };\n    }\n    \n    return {\n      equationLaTeX: expr,\n      inputs,\n      substitutionLaTeX: expr,\n      result: { display: resultDisplay, unit: result.unit },\n      numericResult: result.value,\n    };\n  } catch (error) {\n    // Fallback for cases where unified evaluation fails\n    return {\n      equationLaTeX: expr,\n      inputs,\n      substitutionLaTeX: expr,\n      result: { display: \"Error in evaluation\" },\n    };\n  }\n}","size_bytes":4023},"src/frames/ReportCanvas/CalcBox.tsx":{"content":"import React, { useEffect, useRef, useState } from \"react\";\nimport katex from \"katex\";\nimport type { CalcBoxModel } from \"./types\";\nimport * as InsertBridge from \"../../referencing/insertTarget\";\nimport { startDrag } from \"./drag\";\nimport { normalizeForParser } from \"../../lib/text/normalize\";\n\ntype Props = {\n  box: CalcBoxModel;\n  selected: boolean;\n  onSelect: (id: string, e: React.PointerEvent<HTMLElement>) => void;\n  onCommit: (id: string, raw: string) => void;\n  onCancel: (id: string) => void;\n  onEnterEdit: (id: string) => void;\n  onMove: (id: string, x: number, y: number) => void;\n  onDragEnd: (id: string) => void;\n  bringToFront: (id: string) => void;\n  onResize: (id: string, w: number) => void;\n  onFullWidth: (id: string) => void;\n  onDragDelta?: (id: string, dx: number, dy: number) => void;\n};\n\nfunction CalcBox({ box, selected, onSelect, onCommit, onCancel, onEnterEdit, onMove, onDragEnd, bringToFront, onResize, onDragDelta }: Props) {\n  const inputRef = useRef<HTMLInputElement | null>(null);\n  // Use src for editing (clean), raw for display (LaTeX)\n  const [draft, setDraft] = useState(box.mode === 'edit' ? (box.src || box.raw) : box.raw);\n  const draftRef = useRef(draft);\n  useEffect(() => { draftRef.current = draft; }, [draft]);\n  const committedRef = useRef(false);\n\n  // Critical fix: Use src (clean) for editing, raw (LaTeX) for display\n  useEffect(() => { \n    if (box.mode === 'edit') {\n      setDraft(box.src || box.raw);  // Clean source for editing\n    } else {\n      setDraft(box.raw);  // LaTeX version for display\n    }\n  }, [box.raw, box.src, box.mode]);\n  // If we re-enter edit mode and a headless sticky target exists for this box, hydrate from it\n  useEffect(() => {\n    if (box.mode === 'edit') {\n      const t = (InsertBridge as any).getInsertTarget?.();\n      if (t && t.kind === 'report' && (t as any).boxId === box.id && typeof t.getText === 'function') {\n        const text = t.getText();\n        if (typeof text === 'string') setDraft(text);\n      }\n    }\n  }, [box.mode, box.id]);\n  useEffect(() => { if (box.mode === \"edit\") inputRef.current?.focus(); }, [box.mode]);\n  useEffect(() => {\n    if (box.mode === 'edit' && inputRef.current) {\n      const el = inputRef.current;\n      const target = {\n        kind: 'report' as const,\n        boxId: box.id,\n        getText: () => el.value,\n        setText: (next: string) => {\n          setDraft(next);\n          // Re-set same target to notify listeners after React applies value\n          setTimeout(() => InsertBridge.setInsertTarget(target, { sticky: true }), 0);\n        },\n        getSelection: () => {\n          const s = el.selectionStart ?? el.value.length; const e = el.selectionEnd ?? el.value.length; return { start: s, end: e };\n        },\n        setSelection: (sel: { start: number; end: number } | null) => { if (!sel) return; try { el.selectionStart = sel.start; el.selectionEnd = sel.end; } catch {} },\n        commit: () => { if (el.value != null) onCommit(box.id, el.value); },\n        cancel: () => onCancel(box.id),\n        insert: (text: string) => {\n          const start = el.selectionStart ?? el.value.length;\n          const end = el.selectionEnd ?? el.value.length;\n          const next = el.value.slice(0, start) + text + el.value.slice(end);\n          setDraft(next);\n          setTimeout(() => { el.selectionStart = el.selectionEnd = start + text.length; el.focus(); }, 0);\n          setTimeout(() => InsertBridge.setInsertTarget(target, { sticky: true }), 0);\n        }\n      };\n      InsertBridge.setInsertTarget(target, { sticky: true });\n      // Keep session alive across focus changes; on unmount/leave, promote to headless buffer target\n      return () => {\n        const headless = {\n          kind: 'report' as const,\n          boxId: box.id,\n          getText: () => draftRef.current,\n          setText: (next: string) => { draftRef.current = next; },\n          getSelection: () => null,\n          setSelection: () => {},\n          commit: () => { const v = draftRef.current; if (typeof v === 'string') onCommit(box.id, v); },\n          cancel: () => onCancel(box.id),\n        };\n        InsertBridge.setInsertTarget(headless, { sticky: true });\n      };\n    }\n    // Not in edit mode; leave any existing sticky target in place so Formula Bar can keep editing\n    return () => {};\n  }, [box.mode]);\n\n  const handlePointerDown: React.PointerEventHandler<HTMLElement> = (e) => {\n    if ((e.target as HTMLElement).classList.contains(\"resize-handle\")) return;\n    const detail = (e as any).detail as number | undefined;\n    if (detail && detail >= 2) { e.stopPropagation(); onEnterEdit(box.id); return; }\n    onSelect(box.id, e);\n    if (box.mode === \"edit\") return;\n    bringToFront(box.id);\n    const startX = e.clientX;\n    const startY = e.clientY;\n    const threshold = 3;\n    let started = false;\n    const onMoveWin = (ev: PointerEvent) => {\n      const dx0 = Math.abs(ev.clientX - startX);\n      const dy0 = Math.abs(ev.clientY - startY);\n      if (!started && (dx0 > threshold || dy0 > threshold)) {\n        started = true;\n      }\n      if (!started) return;\n      if (onDragDelta) {\n        onDragDelta(box.id, ev.clientX - startX, ev.clientY - startY);\n      } else {\n        const nx = Math.round((box.x + (ev.clientX - startX)) / 8) * 8;\n        const ny = Math.round((box.y + (ev.clientY - startY)) / 8) * 8;\n        onMove(box.id, nx, ny);\n      }\n    };\n    const onUpWin = () => {\n      window.removeEventListener('pointermove', onMoveWin as any);\n      window.removeEventListener('pointerup', onUpWin as any);\n      onDragEnd(box.id);\n    };\n    window.addEventListener('pointermove', onMoveWin as any);\n    window.addEventListener('pointerup', onUpWin as any);\n  };\n\n  const onInputKeyDown: React.KeyboardEventHandler<HTMLInputElement> = (e) => {\n    if (e.key === \"Enter\") {\n      e.preventDefault();\n      const v = draft;\n      committedRef.current = true;\n      // Defer commit to after blur so we have a single, unified pathway\n      // Manually blur to trigger onBlur handler exactly once\n      window.requestAnimationFrame(() => {\n        inputRef.current?.blur();\n        onCommit(box.id, v);\n      });\n    }\n    else if (e.key === \"Escape\") { e.preventDefault(); onCancel(box.id); }\n  };\n\n  const onRenderKeyDown: React.KeyboardEventHandler<HTMLElement> = (e) => {\n    if (e.key === \"Enter\") { e.preventDefault(); onEnterEdit(box.id); }\n  };\n\n  const onResizePointerDown: React.PointerEventHandler<HTMLDivElement> = (e) => {\n    e.stopPropagation();\n    e.preventDefault();\n    const startW = box.w ?? 200;\n    startDrag(e.nativeEvent, (dx) => {\n      const nextW = Math.max(200, Math.min(1000, startW + dx));\n      onResize(box.id, nextW);\n    }, () => {});\n  };\n\n  const className = `calc-box ${box.mode}${selected ? \" selected\" : \"\"}`;\n  const style: React.CSSProperties = { left: box.x, top: box.y, ['--w' as any]: box.w ? `${box.w}px` : undefined, zIndex: box.z };\n\n  return (\n    <div className={className} style={style} onPointerDown={box.mode === 'render' ? handlePointerDown : undefined} data-id={box.id}>\n      {box.mode === \"edit\" ? (\n        <input\n          ref={inputRef}\n          className=\"calc-input\"\n          value={draft}\n          onChange={(e) => setDraft(e.target.value)}\n          onPaste={(e) => {\n            const pasted = e.clipboardData.getData('text/plain');\n            if (pasted != null) {\n              e.preventDefault();\n              const el = inputRef.current;\n              if (!el) return;\n              const start = el.selectionStart ?? draft.length;\n              const end = el.selectionEnd ?? draft.length;\n              const ins = normalizeForParser(pasted);\n              const next = draft.slice(0, start) + ins + draft.slice(end);\n              setDraft(next);\n              setTimeout(() => { try { el.selectionStart = el.selectionEnd = start + ins.length; } catch {} }, 0);\n            }\n          }}\n          onKeyDown={onInputKeyDown}\n          onBlur={() => {\n            // Do not auto-commit on blur; keep edit session active via sticky InsertTarget\n            committedRef.current = false;\n          }}\n          placeholder={box.renderAsMath ? (box.src ? box.src : \"Type raw expression…\") : undefined}\n        />\n      ) : (\n        <div\n          className=\"calc-render\"\n          onDoubleClick={(e) => { e.stopPropagation(); onEnterEdit(box.id); }}\n          onKeyDown={onRenderKeyDown}\n          tabIndex={0}\n          style={{ outline: 'none', padding: '4px 6px', minHeight: 32, display: 'inline-block', userSelect: 'none', position: 'relative' }}\n          onPointerDown={handlePointerDown}\n        >\n          {true ? (\n            <span\n              ref={(el) => {\n                if (!el) return;\n                try {\n                  const buildUnitToken = (tok: string): string => {\n                    const m = /^([A-Za-z]+)(?:\\^(-?\\d+))?$/.exec(tok.trim());\n                    if (!m) return `\\\\mathrm{${tok}}`;\n                    const base = `\\\\mathrm{${m[1]}}`;\n                    const exp = m[2] ? `^{${m[2]}}` : '';\n                    return `${base}${exp}`;\n                  };\n                  const buildUnitSide = (side: string): string => {\n                    // Split tokens (allow hyphen or dot for composite names like kip-ft if needed)\n                    const parts = side.split(/[\\u00B7\\.-]/g).map(s => s.trim()).filter(Boolean);\n                    return parts.map(buildUnitToken).join(' \\\\cdot ');\n                  };\n                  const buildUnitTex = (u: string): string => {\n                    if (!u) return '';\n                    const slash = u.indexOf('/');\n                    if (slash >= 0) {\n                      const num = u.slice(0, slash);\n                      const den = u.slice(slash + 1);\n                      return `\\\\frac{${buildUnitSide(num)}}{${buildUnitSide(den)}}`;\n                    }\n                    return buildUnitSide(u);\n                  };\n                  const toTeXName = (name: string) => {\n                    if (!name) return name;\n                    return name.length > 1 ? `${name[0]}_{${name.slice(1)}}` : name;\n                  };\n                   const buildTeX = (): string => {\n                    // Build TeX from src when in render mode; avoid using TeX in edit mode\n                    if (box.mode === 'render' && box.renderAsMath && box.src) {\n                      // Reuse simple TeX builder for definitions/text fallback\n                      // This path keeps TeX generation at render-time only\n                      // More robust TeX is already produced upstream when committing\n                      const s = box.src;\n                      const def = /^\\s*([A-Za-z][A-Za-z0-9_']*)\\s*=\\s*(.+?)\\s*$/.exec(s);\n                      if (def) {\n                        const name = def[1];\n                        const rhsRaw = def[2];\n                        return `${name} = ${rhsRaw}`.replace(/\\*/g, ' \\\\cdot ');\n                      }\n                      return s.replace(/\\*/g, ' \\\\cdot ');\n                    }\n                    // Variable definition: Name = value [unit]\n                    const def = /^\\s*([A-Za-z][A-Za-z0-9_']*)\\s*=\\s*(.+?)\\s*$/.exec(box.raw);\n                    if (def) {\n                      const name = toTeXName(def[1]);\n                      const rhsRaw = def[2];\n                      // Try to split RHS into number and unit, allowing no-space (e.g., .82kip/ft)\n                      const numUnit = /^\\s*([-+]?((?:\\d+\\.\\d+)|(?:\\d+\\.)|(?:\\.\\d+)|(?:\\d+)))(?:\\s*([A-Za-z][A-Za-z0-9]*(?:[\\u00B7·\\.-][A-Za-z][A-Za-z0-9]*)*(?:\\/[A-Za-z][A-Za-z0-9]*(?:[\\u00B7·\\.-][A-Za-z][A-Za-z0-9]*)*)?(?:\\^-?\\d+)?))?\\s*$/.exec(rhsRaw);\n                      let val = rhsRaw.trim();\n                      let unit = '';\n                      if (numUnit) {\n                        val = numUnit[1];\n                        unit = (numUnit[3] || '').trim();\n                      } else {\n                        // Fallback: split on first whitespace\n                        const parts = /^([^\\s]+)\\s*(.*)$/.exec(rhsRaw.trim());\n                        if (parts) { val = parts[1]; unit = (parts[2] || '').trim(); }\n                      }\n                      const unitTex = unit ? buildUnitTex(unit.replace(/\\s+/g, '')) : '';\n                      return unitTex ? `${name} = ${val}\\\\,${unitTex}` : `${name} = ${val}`;\n                    }\n                    // Text: render with \\text{...} and escape braces/backslashes/dollars\n                    const esc = box.raw\n                      .replace(/\\\\/g, \"\\\\\\\\\")\n                      .replace(/\\{/g, \"\\\\{\")\n                      .replace(/\\}/g, \"\\\\}\")\n                      .replace(/\\$/g, \"\\\\$\");\n                    return `\\\\text{${esc}}`;\n                  };\n                  const tex = buildTeX();\n                  try {\n                    katex.render(tex, el, { throwOnError: false, displayMode: false });\n                  } catch {\n                    const esc = box.raw.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\{/g, \"\\\\{\").replace(/\\}/g, \"\\\\}\");\n                    katex.render(`\\\\text{${esc}}`, el, { throwOnError: false, displayMode: false });\n                  }\n                } catch {\n                  try {\n                    const esc = box.raw.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\{/g, \"\\\\{\").replace(/\\}/g, \"\\\\}\");\n                    katex.render(`\\\\text{${esc}}`, el, { throwOnError: false, displayMode: false });\n                  } catch {}\n                }\n              }}\n              style={{ display: 'inline-block', minHeight: 24, pointerEvents: 'none' }}\n              onDoubleClick={(e) => { e.stopPropagation(); onEnterEdit(box.id); }}\n              onPointerDown={handlePointerDown}\n            />\n          ) : null}\n          {box.mode === 'render' && box.resultText && (\n            <span className=\"result-chip\" style={{ marginLeft: 8, opacity: 0.9 }}>\n              = {box.resultText}\n            </span>\n          )}\n          {/* Interaction overlay is only active in render mode; disabled in edit mode for text selection */}\n          {box.mode === 'render' && (\n            <div\n              style={{ position: 'absolute', top: 0, right: 0, bottom: 0, left: 0, zIndex: 3, background: 'transparent', pointerEvents: 'auto' }}\n              onPointerDown={handlePointerDown}\n              onDoubleClick={(e) => { e.stopPropagation(); onEnterEdit(box.id); }}\n            />\n          )}\n        </div>\n      )}\n      <div className=\"resize-handle\" onPointerDown={onResizePointerDown} />\n    </div>\n  );\n}\n\nexport default CalcBox;","size_bytes":14620},"src/frames/ReportCanvas/ReportCanvas.tsx":{"content":"import React, { useEffect, useRef, useState } from \"react\";\nimport CalcBox from \"./CalcBox\";\nimport * as InsertBridge from \"../../referencing/insertTarget\";\nimport type { CalcBoxModel } from \"./types\";\nimport { classifyLine, recompute as recomputePad } from \"../ReportPad/model\";\nimport { computeBoxes } from \"./compute\";\nimport { parseAddress } from \"../../referencing/a1\";\n// import katex from 'katex';\nimport type { HistoryProxy } from \"../../history/proxy\";\nimport { EditBoxCommand } from \"../../history/commands/report/EditBoxCommand\";\nimport { normalizeForParser, collapseDuplicateUnits } from \"../../lib/text/normalize\";\nimport { parse as parseUnified, evaluate as evaluateUnified, formatQuantity, classifyInput } from \"../../unified_parser\";\n// TeX formatting now handled by unified parser\n\n function createId(): string { return `bx_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`; }\nconst STORAGE_BASE = 'reportCanvas';\n\nfunction docKey(id: string) { return `${STORAGE_BASE}:doc:${id}`; }\n\ntype Props = {\n  getCellDisplay: (r: number, c: number) => string;\n  // Required stable document identity. The component will load/save under this id.\n  docId: string;\n  onActiveEditChange?: (payload: { source: 'report'|'sheet'; value: string } | null) => void;\n  reportHotkeys?: { selectTool?: string; addTool?: string };\n  history: HistoryProxy;\n  bindBoxesAccessor: (get: () => CalcBoxModel[], set: (next: CalcBoxModel[] | ((prev: CalcBoxModel[]) => CalcBoxModel[])) => void) => void;\n};\n\nexport default function ReportCanvas({ getCellDisplay, docId, onActiveEditChange, reportHotkeys, history, bindBoxesAccessor }: Props) {\n  // eslint-disable-next-line no-console\n  console.log('[BOOT] ReportCanvas: render for docId', docId);\n  const [boxes, setBoxes] = useState<CalcBoxModel[]>([]);\n  const boxesRef = useRef<CalcBoxModel[]>(boxes);\n  useEffect(() => { boxesRef.current = boxes; }, [boxes]);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const surfaceRef = useRef<HTMLDivElement | null>(null);\n  const wrapRef = useRef<HTMLDivElement | null>(null);\n  const [zTop, setZTop] = useState(1);\n  const dragSnapshotRef = useRef<null | { ids: Set<string>; start: Map<string, { x: number; y: number }>; before?: CalcBoxModel[] }>(null);\n  const marqueeRef = useRef<null | { startX: number; startY: number; el: HTMLDivElement }>(null);\n  const spaceHeldRef = useRef(false);\n  const [tool, setTool] = useState<'create' | 'select'>('select');\n  // Helper for global hotkeys: add a box at viewport center when 'a' is pressed\n  const addBoxAtCenter = () => {\n    const canvas = surfaceRef.current; if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = canvas.scrollLeft + Math.max(0, rect.width / 2 - 100);\n    const y = canvas.scrollTop + Math.max(0, rect.height / 2 - 20);\n    addBoxAt(x, y);\n  };\n  const saveTimeoutRef = useRef<number | null>(null);\n  // const resizingTimerRef = useRef<number | null>(null);\n  // const lastResizeIdRef = useRef<string | null>(null);\n  // When the browser performs native history on a focused editable, suppress our custom history in that tick\n  const nativeHistoryTickRef = useRef(false);\n\n  const isEditableTarget = (t: EventTarget | null): boolean => {\n    const el = t as HTMLElement | null;\n    if (!el) return false;\n    if (el.isContentEditable) return true;\n    const tag = el.tagName;\n    if (tag === 'INPUT' || tag === 'TEXTAREA') return true;\n    let p = el.parentElement;\n    for (let i = 0; i < 3 && p; i += 1, p = p.parentElement) {\n      if (p.isContentEditable) return true;\n      const tg = p.tagName;\n      if (tg === 'INPUT' || tg === 'TEXTAREA') return true;\n    }\n    return false;\n  };\n\n  // const cloneBoxes = (arr: CalcBoxModel[]): CalcBoxModel[] => arr.map((b) => ({ ...b }));\n  // bind boxes accessor to shared history ctx (uses refs to avoid stale closures)\n  useEffect(() => {\n    // eslint-disable-next-line no-console\n    console.log('[BOOT] ReportCanvas: bindBoxesAccessor');\n    bindBoxesAccessor(\n      () => boxesRef.current,\n      (next: any) => {\n        const prev = boxesRef.current;\n        const computed = typeof next === 'function' ? next(prev) : next;\n        if (import.meta.env.DEV) {\n          // eslint-disable-next-line no-console\n          console.trace('[REPORT] setBoxes', { action: 'ctx.setBoxes', prevLen: prev.length, nextLen: computed?.length ?? -1, ids: Array.isArray(computed) ? computed.map((b: any) => b.id) : [] });\n          if (Array.isArray(computed) && computed.length === 0 && prev.length > 0) {\n            // Guard against accidental mass-delete during debugging\n            // eslint-disable-next-line no-console\n            console.error('[REPORT] Prevented mass-delete (next empty). Returning prev snapshot.');\n            return;\n          }\n        }\n        // Always recompute derived fields (resultText/error/TeX) after any history-driven mutation\n        setBoxes(computeBoxes(computed, getCellDisplay));\n      }\n    );\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  // all undo/redo now goes through shared history\n\n  const isEditing = (id: string) => boxes.find((b) => b.id === id)?.mode === \"edit\";\n  const anyEditing = () => Array.from(selectedIds).some((id) => isEditing(id));\n\n  // Track space key state for marquee mode (acts as momentary select tool)\n  useEffect(() => {\n    const down = (e: KeyboardEvent) => { if (e.code === 'Space') { spaceHeldRef.current = true; } };\n    const up = (e: KeyboardEvent) => { if (e.code === 'Space') { spaceHeldRef.current = false; } };\n    window.addEventListener('keydown', down); window.addEventListener('keyup', up);\n    return () => { window.removeEventListener('keydown', down); window.removeEventListener('keyup', up); };\n  }, []);\n\n  const bringToFront = (id: string) => {\n    setBoxes((prev) => prev.map((b) => (b.id === id ? { ...b, z: zTop + 1 } : b)));\n    setZTop((z) => z + 1);\n  };\n\n  const addBoxAt = (x: number, y: number) => {\n    const nx = Math.round(x / 8) * 8;\n    const ny = Math.round(y / 8) * 8;\n    const b: CalcBoxModel = { id: createId(), x: nx, y: ny, z: zTop + 1, kind: \"calc\", mode: \"edit\", raw: \"\" };\n    setZTop((z) => z + 1);\n    if (history.isReady()) history.push(new EditBoxCommand((prev) => {\n      return [...prev, b];\n    }, 'add', new Set([b.id])));\n    setSelectedIds(new Set([b.id]));\n  };\n\n  const recompute = (nextBoxes: CalcBoxModel[]) => computeBoxes(nextBoxes, getCellDisplay);\n\n  function toTexFromRaw(raw: string): string {\n    const s = raw.trim();\n    // If it already looks like TeX (has \\\\command), return as-is\n    if (/\\\\[a-zA-Z]+/.test(s)) return s;\n\n    // Use unified parser for all parsing and formatting\n    try {\n      const result = evaluateUnified(s);\n      return formatQuantity(result);\n    } catch {\n      // Fallback for non-evaluable expressions - simple text conversion\n      return s.replace(/\\*/g, ` \\\\cdot `);\n    }\n  }\n\n  // Helpers to render ReportPad AST (unit aware) into TeX\n  const greek: Record<string, string> = { alpha:'\\\\alpha', beta:'\\\\beta', gamma:'\\\\gamma', delta:'\\\\delta', epsilon:'\\\\epsilon', zeta:'\\\\zeta', eta:'\\\\eta', theta:'\\\\theta', iota:'\\\\iota', kappa:'\\\\kappa', lambda:'\\\\lambda', mu:'\\\\mu', nu:'\\\\nu', xi:'\\\\xi', omicron:'o', pi:'\\\\pi', rho:'\\\\rho', sigma:'\\\\sigma', tau:'\\\\tau', upsilon:'\\\\upsilon', phi:'\\\\phi', chi:'\\\\chi', psi:'\\\\psi', omega:'\\\\omega' };\n  // Known unit symbols to render in upright roman (not italics)\n  const unitNames: Set<string> = new Set(['m','mm','in','ft','N','kN','lb','lbs','kip','Pa','kPa','MPa','GPa','psi','psf','ksi']);\n  // const texName = (name: string): string => {\n  //   const lower = name.trim().toLowerCase();\n  //   if (greek[lower]) return greek[lower];\n  //   if (unitNames.has(name)) return `\\\\mathrm{${name}}`;\n  //   if ([ 'sin','cos','tan','ln','log' ].includes(lower)) return `\\\\${lower}`;\n  //   if (name.length > 1) return `${name[0]}_{${name.slice(1)}}`;\n  //   return name;\n  // };\n\n  // remove legacy TeX helpers; TeX is built centrally from the unified pipeline now\n\n  // Use unified parser's formatQuantity for all number formatting\n  // function formatQuantity(q: any): string { return formatNumber(q?.valueSI ?? 0); }\n\n  // Build name->display map from current boxes using report pad evaluation\n  // const buildNameDisplayMap = (...) => new Map<string, string>();\n\n  // Build name -> Quantity map for substitution/evaluation\n  // const buildNameQuantityMap = (...) => new Map<string, any>();\n\n  // remove legacy Pad AST normalization flow\n\n  // const dedupeConsecutive = (arr: string[]): string[] => arr.filter((s, i) => i === 0 || s !== arr[i - 1]);\n\n  function regenerateMathBoxes(input: CalcBoxModel[]): CalcBoxModel[] {\n    return input.map((b) => {\n      if (!b.renderAsMath || !b.src) return b;\n      try {\n        const parsed = parseUnified(b.src);\n        const formatted = parsed.kind === 'expression' || parsed.kind === 'assignment' ? (() => {\n          try {\n            const result = evaluateUnified(b.src);\n            return formatQuantity(result);\n          } catch {\n            return b.src;\n          }\n        })() : b.src;\n        const tex = formatted; // Using unified parser formatting\n        return { ...b, raw: tex };\n      } catch { return b; }\n    });\n  }\n\n  // Document API (load/save)\n  const loadDoc = (id: string) => {\n    try {\n      const raw = localStorage.getItem(docKey(id));\n      if (raw) {\n        const parsed = JSON.parse(raw) as { boxes: Partial<CalcBoxModel>[] };\n        if (parsed && Array.isArray(parsed.boxes)) {\n          const loaded: CalcBoxModel[] = parsed.boxes.map((b) => ({\n            id: String(b.id ?? createId()), x: Number(b.x ?? 0), y: Number(b.y ?? 0), z: Number(b.z ?? 1),\n            kind: (b.kind as any) ?? 'calc', mode: 'render', raw: String(b.raw ?? ''),\n            src: typeof (b as any).src === 'string' ? String((b as any).src) : undefined,\n            renderAsMath: Boolean((b as any).renderAsMath),\n            w: typeof b.w === 'number' ? b.w : undefined,\n          }));\n          setBoxes(recompute(loaded));\n          const maxZ = loaded.reduce((m, bx) => Math.max(m, bx.z), 1); setZTop(maxZ + 1);\n        } else {\n          setBoxes([]); setZTop(1);\n        }\n      } else {\n        setBoxes([]); setZTop(1);\n      }\n    } catch {\n      setBoxes([]); setZTop(1);\n    }\n  };\n\n  const saveDocWithBoxes = (id: string, boxesToPersist: CalcBoxModel[]) => {\n    try {\n      const toSave = boxesToPersist.map(({ id, x, y, z, kind, raw, src, renderAsMath, w }) => ({ id, x, y, z, kind, raw, src, renderAsMath, w }));\n      localStorage.setItem(docKey(id), JSON.stringify({ boxes: toSave }));\n    } catch {}\n  };\n\n  // const saveDoc = (id: string) => { saveDocWithBoxes(id, boxes); };\n\n  const debouncedSave = (id: string, boxesSnapshot: CalcBoxModel[]) => {\n    if (saveTimeoutRef.current !== null) {\n      window.clearTimeout(saveTimeoutRef.current);\n    }\n    saveTimeoutRef.current = window.setTimeout(() => {\n      saveDocWithBoxes(id, boxesSnapshot);\n      saveTimeoutRef.current = null;\n    }, 300);\n  };\n\n  // Load document on mount or when the doc id changes\n  useEffect(() => {\n    if (!docId) return;\n    loadDoc(docId);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [docId]);\n\n  useEffect(() => {\n    // Unit preferences functionality removed - using unified parser instead\n    const unsub = () => {}; // No-op unsubscriber\n    return () => { unsub(); };\n  }, []);\n\n  // Hotkeys for select/add tool when canvas is focused\n  useEffect(() => {\n    const onKey = (e: KeyboardEvent) => {\n      const focusWithin = surfaceRef.current && surfaceRef.current.contains(document.activeElement);\n      if (!focusWithin) return;\n      const selectKey = (reportHotkeys?.selectTool || 'v').toLowerCase();\n      const addKey = (reportHotkeys?.addTool || 'a').toLowerCase();\n      if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {\n        if (e.key.toLowerCase() === selectKey) { e.preventDefault(); setTool('select'); }\n        else if (e.key.toLowerCase() === addKey) { e.preventDefault(); setTool('create'); }\n      }\n    };\n    window.addEventListener('keydown', onKey);\n    return () => window.removeEventListener('keydown', onKey);\n  }, [reportHotkeys]);\n\n  const handleSurfacePointerDown: React.PointerEventHandler<HTMLDivElement> = (e) => {\n    if (e.target !== surfaceRef.current) return;\n    const isAnyEditing = boxes.some((b) => b.mode === 'edit');\n    // If an input is currently being edited, allow the click to blur the input\n    // and do not start marquee or create interactions here.\n    if (isAnyEditing) {\n      // If a report input is being edited, let clicks elsewhere blur it only when not inserting.\n      // If an insert target is active, keep the report input active so users can click on the sheet to insert refs.\n      if (!InsertBridge.hasInsertTarget()) setSelectedIds(new Set());\n      return;\n    }\n    e.preventDefault();\n    const canvas = surfaceRef.current!;\n    const rect = canvas.getBoundingClientRect();\n    const useMarquee = tool === 'select' || spaceHeldRef.current;\n    const startX = e.clientX - rect.left + canvas.scrollLeft;\n    const startY = e.clientY - rect.top + canvas.scrollTop;\n    let started = false;\n    let el: HTMLDivElement | null = null;\n    const threshold = 4;\n\n    canvas.setPointerCapture?.(e.pointerId);\n\n    const onMove = (ev: PointerEvent) => {\n      const curX = ev.clientX - rect.left + canvas.scrollLeft;\n      const curY = ev.clientY - rect.top + canvas.scrollTop;\n      const dx = Math.abs(curX - startX);\n      const dy = Math.abs(curY - startY);\n      if (useMarquee) {\n        if (!started && (dx > threshold || dy > threshold)) {\n          el = document.createElement('div'); el.className = 'marquee'; el.style.left = `${startX}px`; el.style.top = `${startY}px`; el.style.width = '0px'; el.style.height = '0px';\n          canvas.appendChild(el!); started = true; marqueeRef.current = { startX, startY, el };\n        }\n        if (started && el) {\n          const x = Math.min(curX, startX); const y = Math.min(curY, startY);\n          const w = Math.abs(curX - startX); const h = Math.abs(curY - startY);\n          el.style.left = `${x}px`; el.style.top = `${y}px`; el.style.width = `${w}px`; el.style.height = `${h}px`;\n        }\n      }\n    };\n    const finalize = () => {\n      if (useMarquee && started && el) {\n        const x = parseFloat(el.style.left); const y = parseFloat(el.style.top); const w = parseFloat(el.style.width); const h = parseFloat(el.style.height);\n        const sel = new Set<string>();\n        boxes.forEach((b) => {\n          const bx = b.x; const by = b.y; const bw = (b.w ?? 200); const bh = 40;\n          const overlaps = bx < x + w && bx + bw > x && by < y + h && by + bh > y;\n          if (overlaps) sel.add(b.id);\n        });\n        setSelectedIds(sel);\n        el.remove();\n        marqueeRef.current = null;\n      } else if (!useMarquee) {\n        // Create mode: create a box on simple click\n        addBoxAt(startX, startY);\n      }\n      // Do not force-convert edit box here; let input onBlur handle commit consistently\n    };\n    const onUp = (ev: PointerEvent) => {\n      window.removeEventListener('pointermove', onMove as any);\n      window.removeEventListener('pointerup', onUp as any);\n      window.removeEventListener('pointercancel', onCancel as any);\n      finalize();\n    };\n    const onCancel = () => {\n      window.removeEventListener('pointermove', onMove as any);\n      window.removeEventListener('pointerup', onUp as any);\n      window.removeEventListener('pointercancel', onCancel as any);\n      if (el) { el.remove(); }\n      marqueeRef.current = null;\n    };\n      window.addEventListener('pointermove', onMove as any);\n      window.addEventListener('pointerup', onUp as any);\n      window.addEventListener('pointercancel', onCancel as any);\n  };\n\n  const onBeforeInput: React.FormEventHandler<HTMLDivElement> = (e) => {\n    const evt = e as unknown as InputEvent;\n    const it = (evt && (evt as any).inputType) as string | undefined;\n    if (it && (it === 'historyUndo' || it === 'historyRedo')) {\n      nativeHistoryTickRef.current = true;\n      queueMicrotask(() => { nativeHistoryTickRef.current = false; });\n    }\n  };\n\n  const handleSurfaceDoubleClick: React.MouseEventHandler<HTMLDivElement> = (e) => {\n    if (e.target !== surfaceRef.current) return;\n    const canvas = surfaceRef.current!;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left + canvas.scrollLeft;\n    const y = e.clientY - rect.top + canvas.scrollTop;\n    addBoxAt(x, y);\n  };\n\n    const commit = (id: string, raw: string) => {\n    const trimmed = collapseDuplicateUnits(raw.trim());\n    const normalized = normalizeForParser(trimmed);\n    if (trimmed === \"\") {\n      setBoxes((prev) => {\n        const next = prev.filter((b) => b.id !== id);\n      // Save (debounced) after delete\n      debouncedSave(docId, next);\n        return next;\n      });\n      setSelectedIds((prev) => { const next = new Set(prev); next.delete(id); return next; });\n      return;\n    }\n    if (!history.isReady()) return;\n    history.push(new EditBoxCommand((prev) => {\n      const old = prev.find(b => b.id === id);\n      const defParsed = parseUnified(normalized);\n      const rhs = defParsed.kind === 'assignment' ? normalized.substring(normalized.indexOf('=') + 1).trim() : '';\n      const hasEq = /=/.test(normalized);\n      const hasFunc = /(sqrt|sin|cos|tan|ln|log)\\s*\\(/i.test(normalized);\n      const hasMulDivPow = /[*/^]/.test(normalized);\n      const hasParen = /[()]/.test(normalized);\n      const hasCellRef = /\\b[A-Z]+[1-9][0-9]*\\b/.test(normalized);\n      // Only treat + or - as math when near numbers or uppercase variable-style names\n      const hasPlusMinusNumeric = /(?:\\d|\\))\\s*[+\\-]\\s*(?:\\d|[A-Z(])/.test(trimmed);\n      const hasValidOp = hasFunc || hasMulDivPow || hasParen || hasCellRef || hasPlusMinusNumeric;\n      // Consider a definition \"simple\" if RHS is a single number optionally followed by a unit spec\n      const isSimpleDefinitionRhs = (s: string): boolean => {\n        const unitToken = \"[A-Za-z]+(?:\\\\^-?\\\\d+)?\";\n        const dotGroup = `${unitToken}(?:\\\\s*[\\\\u00B7·.]\\\\s*${unitToken})*`;\n        const unitSpec = `${dotGroup}(?:\\\\s*\\/\\\\s*${dotGroup})?`;\n        const num = \"[-+]?((?:\\\\d+\\\\.\\\\d+)|(?:\\\\d+\\\\.)|(?:\\\\.\\\\d+)|(?:\\\\d+))\";\n        const re = new RegExp(`^\\\\s*${num}(?:\\\\s*${unitSpec})?\\\\s*$`);\n        return re.test(s);\n      };\n      const isSimpleDef = !!(defParsed && isSimpleDefinitionRhs(rhs));\n      const isMath = (!isSimpleDef) && (!!old?.renderAsMath || hasEq || hasValidOp);\n      const converted = isMath ? (() => {\n        try {\n          // Use the new robust parser that handles units correctly\n          const parsed = parseUnified(normalized);\n          const formatted = parsed.kind === 'expression' || parsed.kind === 'assignment' ? (() => {\n            try {\n              const result = evaluateUnified(normalized);\n              return formatQuantity(result);\n            } catch {\n              return normalized;\n            }\n          })() : normalized;\n          // Convert to TeX format for math rendering\n          const texFormatted = formatted; // Using unified parser formatting\n          // CRITICAL: Store the original normalized input for editing, not the expanded result\n          // src = what you typed (for editing): \"A = 5in + 4in\"  \n          // raw = formatted display (for rendering): \"A = 5\\,\\mathrm{in} + 4\\,\\mathrm{in} = 9\\,\\mathrm{in}\"\n          console.log('[COMMIT]', { \n            originalInput: raw,\n            normalized,\n            formatted,\n            texFormatted,\n            storing: { src: normalized, raw: texFormatted }\n          });\n          return { raw: texFormatted, src: normalized, renderAsMath: true };\n          } catch {\n            // Fallback to plain TeX conversion from normalized input\n            return { raw: toTexFromRaw(normalized), src: normalized, renderAsMath: true };\n          }\n      })() : { raw: normalized, src: undefined, renderAsMath: false };\n      let next = prev.map((b) => (b.id === id ? { ...b, ...converted, mode: \"render\" as const } : b));\n      // Recompute dependencies using sources and update resultText\n      const recomputed = recompute(next);\n      // NOTE: Don't call regenerateMathBoxes here - we already parsed the math correctly above\n      // regenerateMathBoxes is only for bulk operations like unit preference changes\n      next = recomputed;\n      // When a definition line like X=1000lb is present elsewhere, ensure the name map will include units\n      // Save (debounced) after commit\n      debouncedSave(docId, next);\n      if (onActiveEditChange) onActiveEditChange(null);\n      return next;\n    }, 'edit'));\n  };\n\n  const cancel = (id: string) => {\n    if (history.isReady()) history.push(new EditBoxCommand((prev) => prev.map((b) => (b.id === id ? { ...b, mode: \"render\" as const } : b)), 'edit', new Set([id])));\n    InsertBridge.setFallbackInsertTarget(null);\n    if (onActiveEditChange) onActiveEditChange(null);\n  };\n\n  const enterEdit = (id: string) => {\n    setBoxes((prev) => prev.map((b) => {\n      if (b.id !== id) return b;\n      // When math-rendered, switch to editing the original source\n      if (b.renderAsMath && b.src) {\n        console.log('[ENTER EDIT]', { \n          id, \n          currentRaw: b.raw, \n          srcField: b.src,\n          renderAsMath: b.renderAsMath,\n          willSetRawTo: b.src\n        });\n        return { ...b, raw: b.src, mode: 'edit' as const };\n      }\n      return { ...b, mode: 'edit' as const };\n    }));\n    InsertBridge.setFallbackInsertTarget({ docId, boxId: id });\n    if (onActiveEditChange) {\n      const b = boxes.find(x => x.id === id);\n      if (b) onActiveEditChange({ source: 'report', value: b.src ?? b.raw });\n    }\n  };\n\n  const move = (id: string, x: number, y: number) => {\n    if (history.isReady()) history.push(new EditBoxCommand((prev) => prev.map((b) => (b.id === id ? { ...b, x, y } : b)), 'move', new Set([id])));\n  };\n\n  const dragEnd = (_id: string) => {\n    dragSnapshotRef.current = null;\n    setBoxes((prev) => { const r = recompute(prev); debouncedSave(docId, r); return r; });\n  };\n\n  const nudge = (ids: Set<string>, dx: number, dy: number) => {\n    if (!history.isReady()) return;\n    history.push(new EditBoxCommand((prev) => {\n      const next = prev.map((b) => (ids.has(b.id) ? { ...b, x: b.x + dx, y: b.y + dy } : b));\n      const r = recompute(next); debouncedSave(docId, r); return r;\n    }, 'nudge', new Set(ids)));\n  };\n\n  const resize = (id: string, w: number) => {\n    if (history.isReady()) history.push(new EditBoxCommand((prev) => { const r = prev.map((b) => (b.id === id ? { ...b, w } : b)); debouncedSave(docId, r); return r; }, 'resize', new Set([id])));\n  };\n\n  const fullWidth = (id: string) => {\n    const canvas = surfaceRef.current; if (!canvas) return;\n    const styles = getComputedStyle(canvas); const pad = parseInt(styles.paddingLeft) + parseInt(styles.paddingRight);\n    const width = canvas.clientWidth - pad;\n    history.push(new EditBoxCommand((prev) => { const r = prev.map((b) => (b.id === id ? { ...b, w: Math.max(200, Math.min(1000, width)) } : b)); debouncedSave(docId, r); return r; }, 'resize', new Set([id])));\n  };\n\n  // Selection logic\n  const onSelectBox = (id: string, e: React.PointerEvent<HTMLElement>) => {\n    const multi = e.shiftKey || e.ctrlKey || e.metaKey;\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (multi) {\n        if (next.has(id)) next.delete(id); else next.add(id);\n      } else {\n        next.clear(); next.add(id);\n      }\n      return next;\n    });\n    // Ensure the canvas has focus so keybindings (Delete, arrows) work\n    surfaceRef.current?.focus();\n  };\n\n  const onDragDelta = (id: string, dx: number, dy: number) => {\n    const ids = selectedIds.size ? selectedIds : new Set([id]);\n    if (!dragSnapshotRef.current) {\n      const start = new Map<string, { x: number; y: number }>();\n      for (const bid of ids) {\n        const b = boxes.find((bx) => bx.id === bid);\n        if (b) start.set(bid, { x: b.x, y: b.y });\n      }\n      dragSnapshotRef.current = { ids: new Set(ids), start, before: boxes.map(b=>({ ...b })) };\n    }\n    const snap = dragSnapshotRef.current;\n    if (!snap) return;\n    history.push(new EditBoxCommand((prev) => prev.map((b) => {\n      if (!snap.ids.has(b.id)) return b;\n      const s = snap.start.get(b.id) || { x: b.x, y: b.y };\n      const nx = Math.round((s.x + dx) / 8) * 8;\n      const ny = Math.round((s.y + dy) / 8) * 8;\n      return { ...b, x: nx, y: ny };\n    }), 'move', snap.ids));\n  };\n\n  const onKeyDown: React.KeyboardEventHandler<HTMLDivElement> = (e) => {\n    // Intercept high-priority history keys when appropriate\n    // Undo/Redo handled by global hotkeys now\n\n    // Cancel marquee overlay\n    if (e.key === 'Escape') {\n      e.preventDefault();\n      if (marqueeRef.current?.el) { marqueeRef.current.el.remove(); marqueeRef.current = null; }\n      setSelectedIds(new Set());\n      history.push(new EditBoxCommand((prev) => prev.map((b) => (b.mode === 'edit' ? { ...b, mode: 'render' as const } : b)), 'edit'));\n      return;\n    }\n\n\n    // Keep Ctrl/Cmd+A select-all in canvas\n    if (e.key.toLowerCase() === 'a' && (e.ctrlKey || e.metaKey)) {\n      e.preventDefault(); setSelectedIds(new Set(boxes.map((b) => b.id))); return;\n    }\n\n    if (selectedIds.size === 0) return; if (anyEditing()) return;\n    const step = e.shiftKey ? 8 : 1;\n    if (e.key === \"ArrowUp\") { e.preventDefault(); nudge(selectedIds, 0, -step); return; }\n    if (e.key === \"ArrowDown\") { e.preventDefault(); nudge(selectedIds, 0, step); return; }\n    if (e.key === \"ArrowLeft\") { e.preventDefault(); nudge(selectedIds, -step, 0); return; }\n    if (e.key === \"ArrowRight\") { e.preventDefault(); nudge(selectedIds, step, 0); return; }\n    if (e.key === \"Delete\" || e.key === \"Backspace\") {\n      e.preventDefault();\n      if (history.isReady()) history.push(new EditBoxCommand((prev) => { const ids = selectedIds; const f = prev.filter((b) => !ids.has(b.id)); debouncedSave(docId, f); return f; }, 'remove', new Set(selectedIds)));\n      setSelectedIds(new Set());\n    } else if (e.key.toLowerCase() === \"f\") {\n      if (selectedIds.size === 1) { e.preventDefault(); const id = Array.from(selectedIds)[0]; fullWidth(id); }\n    }\n  };\n\n  return (\n    <div className=\"canvas-wrap\" ref={wrapRef}>\n      <div className=\"canvas\" ref={surfaceRef} onPointerDown={handleSurfacePointerDown} onDoubleClick={handleSurfaceDoubleClick} onBeforeInput={onBeforeInput} onKeyDown={onKeyDown} tabIndex={0} style={{ touchAction: 'none' }}>\n        <div style={{ position: 'sticky', top: 0, left: 0, display: 'flex', gap: 6, padding: 6, background: 'rgba(17,17,17,0.6)', borderRadius: 6, zIndex: 10, width: 'max-content' }}>\n          <button onClick={() => setTool('select')} className={tool === 'select' ? 'tool-active' : ''} title=\"Select (marquee)\" style={{ padding: '4px 8px', border: '1px solid #444', background: tool === 'select' ? '#2b2b2b' : '#1f1f1f', color: '#efefef' }}>▭ Select</button>\n          <button onClick={() => setTool('create')} className={tool === 'create' ? 'tool-active' : ''} title=\"Create (click to add)\" style={{ padding: '4px 8px', border: '1px solid #444', background: tool === 'create' ? '#2b2b2b' : '#1f1f1f', color: '#efefef' }}>＋ Add</button>\n          {import.meta.env.DEV && history.isReady() && (\n            <span style={{ marginLeft: 8, padding: '2px 6px', border: '1px solid #555', borderRadius: 4, background: '#111', color: '#9ad' }} title=\"History stacks\">\n              {(() => { try { const d = history.debugStacks(); return `U:${d.undoLen} R:${d.redoLen}`; } catch { return 'U:0 R:0'; } })()}\n            </span>\n          )}\n        </div>\n        {boxes.map((b) => (\n             <CalcBox\n            key={b.id}\n            box={b}\n            selected={selectedIds.has(b.id)}\n            onSelect={onSelectBox}\n            onCommit={commit}\n            onCancel={cancel}\n            onEnterEdit={enterEdit}\n            onMove={move}\n            onDragEnd={dragEnd}\n            bringToFront={bringToFront}\n            onResize={resize}\n            onFullWidth={fullWidth}\n            onDragDelta={onDragDelta}\n          />\n        ))}\n\n      </div>\n    </div>\n  );\n} ","size_bytes":28407},"src/frames/ReportCanvas/ReportTabs.tsx":{"content":"import React, { useEffect, useState } from \"react\";\r\nimport ReportCanvas from \"./ReportCanvas\";\r\n\r\ntype Props = {\r\n  getCellDisplay: (r: number, c: number) => string;\r\n};\r\n\r\nconst STORAGE_BASE = \"reportCanvas\";\r\nconst DOCS_KEY = `${STORAGE_BASE}:docs`;\r\nconst TABS_KEY = `${STORAGE_BASE}:tabs`;\r\n\r\nfunction docKey(id: string) {\r\n  return `${STORAGE_BASE}:doc:${id}`;\r\n}\r\n\r\nfunction loadDocsList(): string[] {\r\n  try {\r\n    const raw = localStorage.getItem(DOCS_KEY);\r\n    if (raw) {\r\n      const a = JSON.parse(raw);\r\n      if (Array.isArray(a)) return a.map(String);\r\n    }\r\n  } catch {}\r\n  return [];\r\n}\r\n\r\nfunction saveDocsList(ids: string[]) {\r\n  try {\r\n    localStorage.setItem(DOCS_KEY, JSON.stringify(ids));\r\n  } catch {}\r\n}\r\n\r\nfunction loadTabs(): string[] {\r\n  try {\r\n    const raw = localStorage.getItem(TABS_KEY);\r\n    if (raw) {\r\n      const a = JSON.parse(raw);\r\n      if (Array.isArray(a)) return a.map(String);\r\n    }\r\n  } catch {}\r\n  return [];\r\n}\r\n\r\nfunction saveTabs(tabs: string[]) {\r\n  try {\r\n    localStorage.setItem(TABS_KEY, JSON.stringify(tabs));\r\n  } catch {}\r\n}\r\n\r\nfunction generateUniqueName(base: string, existing: Set<string>): string {\r\n  if (!existing.has(base)) return base;\r\n  let i = 1;\r\n  // Find next available suffix\r\n  while (existing.has(`${base} ${i}`)) i += 1;\r\n  return `${base} ${i}`;\r\n}\r\n\r\nexport default function ReportTabs({ getCellDisplay }: Props) {\r\n  const [tabs, setTabs] = useState<string[]>([]);\r\n  const [active, setActive] = useState<string>(\"\");\r\n\r\n  // Initialize tabs from saved tabs list or from docs list fallback\r\n  useEffect(() => {\r\n    const savedTabs = loadTabs();\r\n    const docs = loadDocsList();\r\n    const initial = savedTabs.length > 0 ? savedTabs : (docs.length > 0 ? docs : [\"Sheet 1\"]);\r\n    const unique = Array.from(new Set(initial));\r\n    setTabs(unique);\r\n    setActive(unique[0]);\r\n    if (savedTabs.length === 0) saveTabs(unique);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (tabs.length === 0) {\r\n      const next = [\"Sheet 1\"];\r\n      setTabs(next);\r\n      setActive(next[0]);\r\n      saveTabs(next);\r\n      return;\r\n    }\r\n    saveTabs(tabs);\r\n  }, [tabs]);\r\n\r\n  const onAdd = () => {\r\n    const existing = new Set(tabs);\r\n    const name = generateUniqueName(\"Sheet\", existing);\r\n    const nextTabs = [...tabs, name];\r\n    setTabs(nextTabs);\r\n    setActive(name);\r\n    // Ensure docs list includes it; no content yet\r\n    const docs = new Set(loadDocsList());\r\n    docs.add(name);\r\n    saveDocsList(Array.from(docs));\r\n  };\r\n\r\n  const onDelete = (name: string) => {\r\n    const idx = tabs.indexOf(name);\r\n    if (idx === -1) return;\r\n    const nextTabs = tabs.filter((t) => t !== name);\r\n    setTabs(nextTabs);\r\n    if (active === name) {\r\n      setActive(nextTabs[ Math.max(0, idx - 1) ] || \"\");\r\n    }\r\n    // Remove from docs list and delete stored document\r\n    try {\r\n      const docs = new Set(loadDocsList());\r\n      docs.delete(name);\r\n      saveDocsList(Array.from(docs));\r\n      localStorage.removeItem(docKey(name));\r\n    } catch {}\r\n  };\r\n\r\n  return (\r\n    <div className=\"report-tabs\" style={{ display: \"flex\", flexDirection: \"column\", height: \"100%\" }}>\r\n      <div className=\"tab-bar\" style={{ display: \"flex\", alignItems: \"center\", gap: 6, padding: 6 }}>\r\n        {tabs.map((t) => (\r\n          <div key={t} style={{ display: \"flex\", alignItems: \"center\", gap: 6 }}>\r\n            <button\r\n              onClick={() => setActive(t)}\r\n              className={t === active ? \"tab-active\" : \"\"}\r\n              style={{ padding: \"4px 8px\", border: \"1px solid #444\", background: t === active ? \"#2b2b2b\" : \"#1f1f1f\", color: \"#efefef\" }}\r\n              title={t}\r\n            >\r\n              {t}\r\n            </button>\r\n            <button\r\n              onClick={() => onDelete(t)}\r\n              title={`Delete ${t}`}\r\n              style={{ padding: \"4px 8px\", border: \"1px solid #444\", background: \"#1f1f1f\", color: \"#efefef\" }}\r\n            >\r\n              ×\r\n            </button>\r\n          </div>\r\n        ))}\r\n        <button onClick={onAdd} title=\"Add sheet\" style={{ padding: \"4px 8px\", border: \"1px solid #444\", background: \"#1f1f1f\", color: \"#efefef\" }}>＋ Add Sheet</button>\r\n      </div>\r\n      <div style={{ flex: 1, minHeight: 0 }} />\r\n    </div>\r\n  );\r\n}\r\n\r\n\r\n","size_bytes":4269},"src/frames/ReportCanvas/__tests__/report-undo.equation.spec.tsx":{"content":"import { describe, it, expect } from 'vitest';\r\nimport { computeBoxes } from '../../ReportCanvas/compute';\r\n\r\ntype Box = any;\r\n\r\ndescribe('ReportCanvas undo retains equals/result', () => {\r\n  const getCellDisplay = (_r: number, _c: number) => '';\r\n\r\n  it('recomputes resultText after a history restore', () => {\r\n    const initial: Box[] = [{ id: '1', x:0, y:0, z:1, kind:'calc', mode:'render', raw:'', src:'A = 5 in + 4 in', renderAsMath:true }];\r\n    const withComputed = computeBoxes(initial, getCellDisplay);\r\n    expect(withComputed[0].resultText).toBeTruthy();\r\n    // Simulate history restore of a bare snapshot (no computed fields)\r\n    const restored: Box[] = [{ id: '1', x:0, y:0, z:1, kind:'calc', mode:'render', raw: withComputed[0].raw, src:'A = 5 in + 4 in', renderAsMath:true }];\r\n    const recomputed = computeBoxes(restored, getCellDisplay);\r\n    expect(recomputed[0].resultText).toBeTruthy();\r\n  });\r\n});\r\n\r\n\r\n","size_bytes":928},"src/frames/ReportCanvas/compute.ts":{"content":"import type { CalcBoxModel } from './types';\r\nimport { classifyLine, recompute as recomputePad } from '../ReportPad/model';\r\nimport { parseAddress } from '../../referencing/a1';\r\nimport { formatQuantity, classifyInput } from '../../unified_parser';\r\n// Utility function to trim trailing equals\nfunction trimTrailingEquals(text: string): string {\n  return text.replace(/\\s*=\\s*$/, '');\n}\r\n\r\nexport function computeBoxes(\r\n  nextBoxes: CalcBoxModel[],\r\n  getCellDisplay: (r: number, c: number) => string\r\n): CalcBoxModel[] {\r\n  const ordered = [...nextBoxes].sort((a, b) => (a.y - b.y) || (a.x - b.x));\r\n  const doc = { lines: ordered.map((b) => {\r\n    const srcText = (b as any).src ? String((b as any).src) : b.raw;\r\n    const trimmed = trimTrailingEquals(srcText);\r\n    const m = /^([^=]+?)=(.+)$/.exec(trimmed);\r\n    const evalText = m ? m[2].trim() : trimmed;\r\n    const looksMathy = /[=+\\-*/^()]/.test(evalText) || /(sqrt|sin|cos|tan|ln|log)\\s*\\(/i.test(evalText) || /\\b[A-Z]+[1-9][0-9]*\\b/.test(evalText);\r\n    const kind = (!((b as any).renderAsMath) && !looksMathy) ? 'text' : classifyInput(evalText);\r\n    return { id: b.id, text: evalText, kind } as any;\r\n  }) } as any;\r\n  const computed = recomputePad(doc, getCellDisplay, (a1) => parseAddress(a1));\r\n  const idToRes = new Map(computed.lines.map((l: any) => [l.id, l] as const));\r\n  return nextBoxes.map((b) => {\r\n    const line = idToRes.get(b.id);\r\n    const resultText = line?.result ? formatQuantity({ value: line.result.valueSI, valueSI: line.result.valueSI, dims: line.result.dims }) : undefined;\r\n    // Do not mutate raw here; keep raw/src as the user's editable/source text\r\n    return { ...b, resultText, error: line?.error ?? null } as CalcBoxModel;\r\n  });\r\n}\r\n\r\n\r\n","size_bytes":1737},"src/frames/ReportCanvas/drag.ts":{"content":"export function startDrag(\r\n  e: PointerEvent,\r\n  onMove: (dx: number, dy: number) => void,\r\n  onEnd: () => void\r\n) {\r\n  // Prevent text selection/scroll during drag\r\n  e.preventDefault();\r\n\r\n  const startX = e.clientX;\r\n  const startY = e.clientY;\r\n  const target = e.target as Element;\r\n\r\n  target.setPointerCapture?.(e.pointerId);\r\n\r\n  function move(ev: PointerEvent) {\r\n    onMove(ev.clientX - startX, ev.clientY - startY);\r\n  }\r\n\r\n  function cleanup() {\r\n    window.removeEventListener(\"pointermove\", move as any);\r\n    window.removeEventListener(\"pointerup\", up as any);\r\n    window.removeEventListener(\"pointercancel\", cancel as any);\r\n    (target as any).removeEventListener?.(\"lostpointercapture\", lostCapture as any);\r\n    onEnd();\r\n  }\r\n\r\n  function up() { cleanup(); }\r\n  function cancel() { cleanup(); }\r\n  function lostCapture() { cleanup(); }\r\n\r\n  window.addEventListener(\"pointermove\", move as any);\r\n  window.addEventListener(\"pointerup\", up as any);\r\n  window.addEventListener(\"pointercancel\", cancel as any);\r\n  (target as any).addEventListener?.(\"lostpointercapture\", lostCapture as any);\r\n}","size_bytes":1111},"src/frames/ReportCanvas/types.ts":{"content":"export type BoxKind = \"calc\" | \"text\";\r\nexport type BoxMode = \"edit\" | \"render\";\r\n\r\nexport type CalcBoxModel = {\r\n  id: string;\r\n  x: number;\r\n  y: number;\r\n  z: number;\r\n  kind: BoxKind;\r\n  mode: BoxMode;\r\n  raw: string;\r\n  src?: string;\r\n  nameNorm?: string;\r\n  resultText?: string;\r\n  error?: string | null;\r\n  w?: number;\r\n  renderAsMath?: boolean;\r\n};\r\n\r\nexport type Doc = { boxes: CalcBoxModel[] }; ","size_bytes":405},"src/frames/ReportPad/CalcLine.tsx":{"content":"import React from \"react\";\r\nimport type { Line, Quantity } from \"./model\";\r\nimport { convertDisplay } from \"./model\";\r\n\r\ntype Props = {\r\n  line: Line;\r\n  onChange: (text: string) => void;\r\n};\r\n\r\nfunction formatQuantity(q?: Quantity): string {\r\n  if (!q) return \"\";\r\n  try {\r\n    const { value, unit } = convertDisplay(q);\r\n    const v = Number.isFinite(value) ? (Math.abs(value) >= 1e6 || Math.abs(value) < 1e-3 ? value.toExponential(3) : value.toFixed(3).replace(/\\.0+$/, \"\").replace(/\\.$/, \"\")) : String(value);\r\n    return unit ? `${v} ${unit}` : `${v}`;\r\n  } catch { return \"\"; }\r\n}\r\n\r\nexport default function CalcLine({ line, onChange }: Props) {\r\n  const isDef = line.kind === \"def\";\r\n  const isExpr = line.kind === \"expr\";\r\n  const resultText = formatQuantity(line.result);\r\n\r\n  return (\r\n    <div style={{ display: \"grid\", gridTemplateColumns: \"1fr 280px\", gap: 12, alignItems: \"start\", padding: \"4px 0\" }}>\r\n      <textarea\r\n        value={line.text}\r\n        onChange={(e) => onChange(e.target.value)}\r\n        rows={1}\r\n        style={{\r\n          width: \"100%\",\r\n          minHeight: 24,\r\n          padding: 4,\r\n          boxSizing: \"border-box\",\r\n          background: \"#1f1f1f\",\r\n          color: \"#efefef\",\r\n          border: line.error ? \"1px solid #cc3d3d\" : \"1px solid #4a4a4a\",\r\n          borderRadius: 4,\r\n          fontFamily: \"ui-monospace, SFMono-Regular, Menlo, Consolas, monospace\",\r\n          resize: \"vertical\",\r\n        }}\r\n      />\r\n      <div style={{ textAlign: \"right\", paddingTop: 6 }}>\r\n        {line.error ? (\r\n          <span style={{ color: \"#f87171\", fontSize: 12 }}>{line.error}</span>\r\n        ) : isExpr ? (\r\n          <span style={{ color: \"#9ade7a\", fontWeight: 600 }}>= {resultText}</span>\r\n        ) : isDef ? (\r\n          <span style={{ color: \"#8aa0ff\", opacity: 0.8 }}>{resultText}</span>\r\n        ) : null}\r\n      </div>\r\n    </div>\r\n  );\r\n} ","size_bytes":1891},"src/frames/ReportPad/ReportPad.tsx":{"content":"import React, { useEffect, useRef, useState } from \"react\";\r\nimport type { Doc, Line } from \"./model\";\r\nimport { recompute, convertDisplay } from \"./model\";\r\nimport { parseAddress } from \"../../referencing/a1\";\r\nimport { parse as parseUnified, classifyInput } from \"../../unified_parser\";\r\n\r\ntype Props = {\r\n  getCellDisplay: (r: number, c: number) => string;\r\n};\r\n\r\nfunction createId(): string {\r\n  return `ln_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;\r\n}\r\n\r\nfunction makeEmptyDoc(): Doc {\r\n  return { lines: [{ id: createId(), text: \"\", kind: \"text\" }] as any };\r\n}\r\n\r\nfunction extractRawTextFromParagraph(p: HTMLElement): string {\r\n  const clone = p.cloneNode(true) as HTMLElement;\r\n  clone.querySelectorAll(\"span.result-chip\").forEach((el) => el.remove());\r\n  return clone.textContent ?? \"\";\r\n}\r\n\r\nfunction formatResultText(line: Line): string {\r\n  if (!line.result) return \"\";\r\n  try {\r\n    const { value, unit } = convertDisplay(line.result);\r\n    const v = Number.isFinite(value)\r\n      ? Math.abs(value) >= 1e6 || Math.abs(value) < 1e-3\r\n        ? value.toExponential(3)\r\n        : value.toFixed(3).replace(/\\.0+$/, \"\").replace(/\\.$/, \"\")\r\n      : String(value);\r\n    return `${v}${unit ? \" \" : \"\"}${unit ?? \"\"}`;\r\n  } catch {\r\n    return \"\";\r\n  }\r\n}\r\n\r\nexport default function ReportPad({ getCellDisplay }: Props) {\r\n  const [doc, setDoc] = useState<Doc>(makeEmptyDoc());\r\n  const padRef = useRef<HTMLDivElement | null>(null);\r\n\r\n  const recomputeDoc = (d: Doc): Doc => recompute(d, getCellDisplay, (a1) => parseAddress(a1));\r\n\r\n  // On mount: ensure at least one paragraph exists\r\n  useEffect(() => {\r\n    const pad = padRef.current;\r\n    if (!pad) return;\r\n    if (!pad.firstElementChild) {\r\n      const p = document.createElement(\"div\");\r\n      p.setAttribute(\"data-id\", doc.lines[0].id);\r\n      p.innerHTML = \"\";\r\n      pad.appendChild(p);\r\n    }\r\n    // Initial compute\r\n    setDoc((prev) => recomputeDoc(prev));\r\n  }, []);\r\n\r\n  // Decorate paragraphs with result chip and error state without touching main text\r\n  useEffect(() => {\r\n    const pad = padRef.current;\r\n    if (!pad) return;\r\n    const paras = Array.from(pad.children) as HTMLElement[];\r\n    paras.forEach((pEl, idx) => {\r\n      const line = doc.lines[idx];\r\n      if (!line) return;\r\n      if (!pEl.getAttribute(\"data-id\")) pEl.setAttribute(\"data-id\", line.id);\r\n      // Remove any prior chip\r\n      pEl.querySelectorAll(\"span.result-chip\").forEach((el) => el.remove());\r\n      // Compute base display text for the paragraph without chips\r\n      const rawBase = extractRawTextFromParagraph(pEl);\r\n      const parsed = parseUnified(rawBase);\r\n      const baseText = parsed.kind === 'assignment' ? rawBase : rawBase.replace(/\\s*=\\s*$/, '');\r\n      if (pEl.textContent?.trim() !== baseText.trim()) {\r\n        // Replace only textContent to avoid disrupting caret structure much\r\n        pEl.textContent = baseText;\r\n      }\r\n      if (line.result && (line.kind === \"def\" || line.kind === \"expr\")) {\r\n        const chip = document.createElement(\"span\");\r\n        chip.className = \"result-chip\";\r\n        chip.textContent = `= ${formatResultText(line)}`;\r\n        pEl.appendChild(document.createTextNode(\" \"));\r\n        pEl.appendChild(chip);\r\n      }\r\n      if (line.error) pEl.setAttribute(\"data-error\", line.error);\r\n      else pEl.removeAttribute(\"data-error\");\r\n    });\r\n  }, [doc]);\r\n\r\n  // Commit a given paragraph element into doc and recompute\r\n  const commitParagraph = (pEl: HTMLElement) => {\r\n    const id = pEl.getAttribute(\"data-id\");\r\n    // If no id, create one and insert a new doc line at the correct index\r\n    const pad = padRef.current!;\r\n    const paras = Array.from(pad.children) as HTMLElement[];\r\n    const idx = paras.indexOf(pEl);\r\n    setDoc((prev) => {\r\n      const next: Doc = { lines: [...prev.lines] } as any;\r\n      let lineId = id;\r\n      if (!lineId) {\r\n        lineId = createId();\r\n        pEl.setAttribute(\"data-id\", lineId);\r\n        // Insert new line at index\r\n        next.lines.splice(idx, 0, { id: lineId, text: \"\", kind: \"text\" } as any);\r\n      }\r\n      const raw = extractRawTextFromParagraph(pEl);\r\n      if (next.lines[idx]) next.lines[idx] = { ...next.lines[idx], text: raw } as any;\r\n      return recomputeDoc(next);\r\n    });\r\n  };\r\n\r\n  const handleKeyDown: React.KeyboardEventHandler<HTMLDivElement> = (e) => {\r\n    if (e.key === \"Enter\" && !e.shiftKey) {\r\n      // Allow default to create new paragraph. After event, commit previous paragraph.\r\n      setTimeout(() => {\r\n        const sel = window.getSelection();\r\n        if (!sel || sel.rangeCount === 0) return;\r\n        let node: Node | null = sel.anchorNode;\r\n        // Find current paragraph element within pad\r\n        let curr: HTMLElement | null = null;\r\n        while (node) {\r\n          if (node instanceof HTMLElement && padRef.current?.contains(node) && (node.parentElement === padRef.current)) {\r\n            curr = node as HTMLElement;\r\n            break;\r\n          }\r\n          node = node.parentNode;\r\n        }\r\n        if (!curr) return;\r\n        // Previous paragraph to commit\r\n        let prev = curr.previousElementSibling as HTMLElement | null;\r\n        if (prev) commitParagraph(prev);\r\n        // Ensure current has an id and an associated doc line\r\n        commitParagraph(curr);\r\n      }, 0);\r\n    }\r\n  };\r\n\r\n  const handleBlur: React.FocusEventHandler<HTMLDivElement> = (e) => {\r\n    const target = e.target as HTMLElement;\r\n    if (!padRef.current?.contains(target)) return;\r\n    if (target.parentElement === padRef.current) {\r\n      commitParagraph(target);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div style={{ maxWidth: 1200, margin: \"0 auto\" }}>\r\n      <div\r\n        ref={padRef}\r\n        className=\"pad\"\r\n        contentEditable\r\n        spellCheck={false}\r\n        onKeyDown={handleKeyDown}\r\n        onBlur={handleBlur}\r\n      />\r\n    </div>\r\n  );\r\n} ","size_bytes":5887},"src/frames/ReportPad/model.test.ts":{"content":"import { describe, it, expect } from 'vitest';\r\nimport { classifyLine, convertDisplay, evalExpr, lex, makeQuantity, parseExpr, recompute } from './model';\r\n\r\nconst getCellDisplay = (r: number, c: number) => {\r\n  const grid: Record<string,string> = { '0:0': '5 in', '0:1': '2 in', '1:0': '10 kN' };\r\n  return grid[`${r}:${c}`] ?? '';\r\n};\r\nconst a1ToRC = (a1: string) => {\r\n  const m = /^([A-Z]+)([1-9][0-9]*)$/.exec(a1);\r\n  if (!m) return null;\r\n  const col = m[1]; const row = parseInt(m[2],10)-1;\r\n  const colIdx = col.split('').reduce((n,ch)=>n*26+(ch.charCodeAt(0)-64),0)-1;\r\n  return { r: row, c: colIdx };\r\n};\r\n\r\ndescribe('ReportPad model', () => {\r\n  it('classifies defs and exprs', () => {\r\n    expect(classifyLine('A = 5 in')).toBe('def');\r\n    expect(classifyLine('5 in + 2 in')).toBe('expr');\r\n  });\r\n\r\n  it('computes definitions with units and dimension mismatch errors', () => {\r\n    const doc = { lines: [\r\n      { id: '1', text: 'A = 5 in', kind: 'text' as const },\r\n      { id: '2', text: 'B = 2 in', kind: 'text' as const },\r\n      { id: '3', text: 'A + B', kind: 'text' as const },\r\n      { id: '4', text: 'A + 10 kN', kind: 'text' as const },\r\n    ] };\r\n    const out = recompute(doc, getCellDisplay, a1ToRC);\r\n    const lines = out.lines;\r\n    expect(lines[0].result).toBeTruthy();\r\n    expect(lines[1].result).toBeTruthy();\r\n    expect(lines[2].result).toBeTruthy();\r\n    expect(lines[3].error).toBeTruthy();\r\n  });\r\n\r\n  it('resolves A1 refs and VLOOKUP exact matches', () => {\r\n    // A1 ref via evalExpr\r\n    const expr = parseExpr(lex('A1 + B1'));\r\n    const q = evalExpr(expr, { getCellDisplay, a1ToRC, ns: new Map() });\r\n    const disp = convertDisplay(q, 'in');\r\n    expect(Math.round(disp.value)).toBe(7);\r\n    expect(disp.unit).toBe('in');\r\n\r\n    // VLOOKUP: build a doc with names, but rely on function throwing for missing impl\r\n    const doc = { lines: [ { id: '1', text: 'X = 5 in', kind: 'text' as const } ] };\r\n    const out = recompute(doc, getCellDisplay, a1ToRC);\r\n    expect(out.lines[0].result).toBeTruthy();\r\n  });\r\n});\r\n\r\n\r\n","size_bytes":2065},"src/frames/ReportPad/model.ts":{"content":"// ReportPad Model - Now using unified parser instead of scattered parsing logic\nimport { parse as parseUnified, evaluate as evaluateUnified, classifyInput, formatQuantity } from \"../../unified_parser\";\nimport { normalizeForParser } from \"../../lib/text/normalize\";\n\nexport type LineKind = \"def\" | \"expr\" | \"text\";\n\nexport type Quantity = {\n  valueSI: number; // SI base value\n  dims: { L: number; M: number; T: number; F: number };\n  displayUnit?: string; // preferred display\n};\n\nexport type Line = {\n  id: string;\n  text: string;\n  kind: LineKind;\n  result?: Quantity;\n  error?: string;\n};\n\nexport type Doc = {\n  lines: Line[];\n};\n\n// Convert unified parser Quantity to ReportPad Quantity format\nfunction convertQuantity(unifiedQty: { value: number; valueSI: number; dims: { L: number; M: number; T: number; F: number }; displayUnit?: string }): Quantity {\n  return {\n    valueSI: unifiedQty.valueSI,\n    dims: unifiedQty.dims,\n    displayUnit: unifiedQty.displayUnit\n  };\n}\n\n// Utility function for backward compatibility\nfunction trimTrailingEquals(text: string): string {\n  return text.replace(/\\s*=\\s*$/, '');\n}\n\n// Check if text looks like a definition (assignment)\nfunction isDefinition(text: string): boolean {\n  const normalized = normalizeForParser(text);\n  try {\n    const parsed = parseUnified(normalized);\n    return parsed.kind === 'assignment';\n  } catch {\n    return false;\n  }\n}\n\nexport function classifyLine(text: string): LineKind {\n  try {\n    return classifyInput(text) as LineKind;\n  } catch {\n    return \"text\";\n  }\n}\n\n// In-memory namespace for variable storage during document evaluation\ntype Namespace = Map<string, Quantity>;\n\nexport function recompute(doc: Doc, getCellDisplay: (r: number, c: number) => string, a1ToRC: (a1: string) => { r: number; c: number } | null): Doc {\n  const ns: Namespace = new Map();\n  const nextLines: Line[] = [];\n  \n  for (const line of doc.lines) {\n    const normalizedText = normalizeForParser(line.text);\n    const kind = classifyLine(normalizedText);\n    let result: Quantity | undefined;\n    let error: string | undefined;\n    \n    if (kind === \"def\" || isDefinition(normalizedText)) {\n      // Handle variable definitions  \n      try {\n        const parsed = parseUnified(normalizedText);\n        if (parsed.kind === 'assignment') {\n          // Create evaluation context\n          const context = {\n            getCell: (ref: string) => {\n              const rc = a1ToRC(ref);\n              if (!rc) return '';\n              return getCellDisplay(rc.r, rc.c);\n            },\n            setVariable: (name: string, value: any) => {\n              ns.set(name.toUpperCase(), convertQuantity(value));\n            },\n            getVariable: (name: string) => {\n              const qty = ns.get(name.toUpperCase());\n              if (qty) {\n                return {\n                  value: qty.valueSI,\n                  valueSI: qty.valueSI, \n                  dims: qty.dims,\n                  displayUnit: qty.displayUnit\n                };\n              }\n              return undefined;\n            }\n          };\n          \n          const unifiedResult = evaluateUnified(normalizedText, context);\n          result = convertQuantity(unifiedResult);\n        }\n      } catch (e: any) {\n        error = e?.message ?? String(e);\n      }\n    } else if (kind === \"expr\") {\n      // Handle expressions\n      try {\n        const context = {\n          getCell: (ref: string) => {\n            const rc = a1ToRC(ref);\n            if (!rc) return '';\n            return getCellDisplay(rc.r, rc.c);\n          },\n          getVariable: (name: string) => {\n            const qty = ns.get(name.toUpperCase());\n            if (qty) {\n              return {\n                value: qty.valueSI,\n                valueSI: qty.valueSI,\n                dims: qty.dims,\n                displayUnit: qty.displayUnit\n              };\n            }\n            return undefined;\n          }\n        };\n        \n        const unifiedResult = evaluateUnified(trimTrailingEquals(normalizedText), context);\n        result = convertQuantity(unifiedResult);\n      } catch (e: any) {\n        error = e?.message ?? String(e);\n      }\n    }\n    \n    nextLines.push({ ...line, kind, result, error });\n  }\n  \n  return { lines: nextLines };\n}\n\n// Create quantity from value and unit (backward compatibility)\nexport function makeQuantity(value: number, unit?: string): Quantity {\n  try {\n    const unifiedQty = { value, unit, valueSI: value, dims: { L: 0, M: 0, T: 0, F: 0 } };\n    if (unit) {\n      // Let unified parser handle unit conversion\n      const testResult = evaluateUnified(`1 ${unit}`);\n      unifiedQty.valueSI = value * testResult.valueSI;\n      unifiedQty.dims = testResult.dims;\n    }\n    return convertQuantity(unifiedQty);\n  } catch {\n    return { valueSI: value, dims: { L: 0, M: 0, T: 0, F: 0 }, displayUnit: unit };\n  }\n}\n\n// Convert quantity for display (backward compatibility)\nexport function convertDisplay(q: Quantity, toUnit?: string): { value: number; unit?: string } {\n  if (!toUnit && q.displayUnit) {\n    // Try to convert back to display unit\n    try {\n      const testResult = evaluateUnified(`1 ${q.displayUnit}`);\n      const factor = testResult.valueSI;\n      return { value: q.valueSI / factor, unit: q.displayUnit };\n    } catch {\n      return { value: q.valueSI, unit: q.displayUnit };\n    }\n  }\n  \n  if (toUnit) {\n    try {\n      const testResult = evaluateUnified(`1 ${toUnit}`);\n      const factor = testResult.valueSI;\n      return { value: q.valueSI / factor, unit: toUnit };\n    } catch {\n      throw new Error(`Unknown unit: ${toUnit}`);\n    }\n  }\n  \n  return { value: q.valueSI, unit: q.displayUnit };\n}\n\n// For backward compatibility - export the classification function that was used\nexport { classifyInput as classifyBasic } from \"../../unified_parser\";","size_bytes":5834},"src/history/Command.ts":{"content":"export type HistoryScope = 'sheet' | 'report';\r\n\r\nexport type CommandCtx = {\r\n  // Sheet grid\r\n  getCell(r: number, c: number): { value: string; format?: any };\r\n  setCell(r: number, c: number, value: string, format?: any): void;\r\n\r\n  // Report boxes (current report document)\r\n  getBoxes(): any[]; // CalcBoxModel[] but avoid tight coupling\r\n  setBoxes(next: any[] | ((prev: any[]) => any[])): void;\r\n}\r\n\r\nexport type Command = {\r\n  name: string;\r\n  scope: HistoryScope;\r\n  do(ctx: CommandCtx): void;\r\n  undo(ctx: CommandCtx): void;\r\n  merge?(next: Command): Command | undefined;\r\n}\r\n\r\n\r\n","size_bytes":589},"src/history/History.ts":{"content":"import type { Command, CommandCtx } from './Command';\n\nexport class History {\n  private undoStack: Command[] = [];\n  private redoStack: Command[] = [];\n  private txn: { name: string; cmds: Command[] } | null = null;\n  private ctx!: CommandCtx;\n  private listeners: Set<() => void> = new Set();\n  private performingUndoRedo = false;\n  private ready = true;\n\n  constructor(ctx?: CommandCtx) {\n    if (ctx) this.ctx = ctx;\n  }\n\n  setCtx(ctx: CommandCtx) {\n    this.ctx = ctx;\n  }\n\n  onChange(cb: () => void): () => void {\n    this.listeners.add(cb);\n    return () => { this.listeners.delete(cb); };\n  }\n\n  private emit() {\n    for (const cb of this.listeners) {\n      try { cb(); } catch {}\n    }\n  }\n\n  beginTransaction(name: string) {\n    if (!this.txn) {\n      if (import.meta.env.DEV) console.log('[history]', { op: 'begin', name, undoLen: this.undoStack.length, redoLen: this.redoStack.length });\n      this.txn = { name, cmds: [] };\n    }\n  }\n\n  commit() {\n    if (!this.txn) return;\n    const cmds = this.txn.cmds;\n    this.txn = null;\n    if (cmds.length === 0) return;\n    const compound: Command = {\n      name: `Txn:${cmds[0].name}`,\n      scope: 'sheet',\n      do: (ctx) => { cmds.forEach(c => c.do(ctx)); },\n      undo: (ctx) => { for (let i = cmds.length - 1; i >= 0; i -= 1) cmds[i].undo(ctx); }\n    };\n    this.undoStack.push(compound);\n    this.redoStack = [];\n    if (import.meta.env.DEV) console.log('[history]', { op: 'commit', undoLen: this.undoStack.length, redoLen: this.redoStack.length });\n    this.emit();\n  }\n\n  rollback() {\n    if (!this.txn) return;\n    for (let i = this.txn.cmds.length - 1; i >= 0; i -= 1) {\n      try { this.txn.cmds[i].undo(this.ctx); } catch {}\n    }\n    if (import.meta.env.DEV) console.log('[history]', { op: 'rollback', size: this.txn.cmds.length });\n    this.txn = null;\n  }\n\n  push(cmd: Command) {\n    if (this.performingUndoRedo) {\n      if (import.meta.env.DEV) console.warn('[history] push() ignored during undo/redo');\n      return;\n    }\n    // Execute immediately so ctx becomes source of truth\n    cmd.do(this.ctx);\n    if (this.txn) {\n      this.txn.cmds.push(cmd);\n      if (import.meta.env.DEV) console.log('[history]', { op: 'push(txn)', name: cmd.name, scope: cmd.scope, undoLen: this.undoStack.length, redoLen: this.redoStack.length });\n      return;\n    }\n    // Coalesce with last step when possible\n    const last = this.undoStack[this.undoStack.length - 1];\n    if (last && last.merge) {\n      const merged = last.merge(cmd);\n      if (merged) { this.undoStack[this.undoStack.length - 1] = merged; this.redoStack = []; return; }\n    }\n    this.undoStack.push(cmd);\n    this.redoStack = [];\n    if (import.meta.env.DEV) console.log('[history]', { op: 'push', name: cmd.name, scope: cmd.scope, undoLen: this.undoStack.length, redoLen: this.redoStack.length });\n    this.emit();\n  }\n\n  undoOnce() {\n    const cmd = this.undoStack.pop();\n    if (!cmd) return;\n    this.performingUndoRedo = true;\n    try { cmd.undo(this.ctx); } finally { this.performingUndoRedo = false; }\n    this.redoStack.push(cmd);\n    if (import.meta.env.DEV) console.log('[history]', { op: 'undo', popped: cmd.name, undoLen: this.undoStack.length, redoLen: this.redoStack.length });\n    this.emit();\n  }\n\n  redoOnce() {\n    const cmd = this.redoStack.pop();\n    if (!cmd) return;\n    this.performingUndoRedo = true;\n    try { cmd.do(this.ctx); } finally { this.performingUndoRedo = false; }\n    this.undoStack.push(cmd);\n    if (import.meta.env.DEV) console.log('[history]', { op: 'redo', popped: cmd.name, undoLen: this.undoStack.length, redoLen: this.redoStack.length });\n    this.emit();\n  }\n\n  canUndo() { return (this.txn ? this.txn.cmds.length > 0 : false) || this.undoStack.length > 0; }\n  canRedo() { return this.redoStack.length > 0; }\n\n  debugStacks() {\n    return {\n      undo: this.undoStack.map(c => c.name),\n      redo: this.redoStack.map(c => c.name),\n      undoLen: this.undoStack.length,\n      redoLen: this.redoStack.length,\n      txnOpen: !!this.txn,\n    };\n  }\n}\n\n\n","size_bytes":4024},"src/history/commands/report/EditBoxCommand.ts":{"content":"import type { Command, CommandCtx } from '../../Command';\r\n\r\ntype EditKind = 'edit' | 'add' | 'remove' | 'move' | 'resize' | 'nudge';\r\n\r\nexport class EditBoxCommand implements Command {\r\n  name = 'EditBox';\r\n  scope: 'report' = 'report';\r\n  private beforeBoxes: any[] | null = null;\r\n  private ts: number;\r\n  private targetIds?: Set<string>;\r\n  private mutate!: (boxes: any[]) => any[];\r\n  private kind!: EditKind;\r\n\r\n  constructor(\r\n    mutate: (boxes: any[]) => any[],\r\n    kind: EditKind = 'edit',\r\n    targetIds?: Set<string>,\r\n    ts?: number,\r\n    beforeSnapshot?: any[] | null,\r\n  ) {\r\n    this.mutate = mutate;\r\n    this.kind = kind;\r\n    this.ts = ts ?? Date.now();\r\n    this.targetIds = targetIds ? new Set(targetIds) : undefined;\r\n    if (beforeSnapshot) this.beforeBoxes = beforeSnapshot.map(b => ({ ...b }));\r\n  }\r\n\r\n  do(ctx: CommandCtx): void {\r\n    if (!this.beforeBoxes) this.beforeBoxes = ctx.getBoxes().map((b: any) => {\r\n      const { mode, hover, selected, resultText, error, ...rest } = b || {};\r\n      // For math boxes, preserve src but reset raw to src (editable version) in snapshots\r\n      if (rest.renderAsMath && rest.src) {\r\n        return { ...rest, raw: rest.src };\r\n      }\r\n      return { ...rest };\r\n    });\r\n    ctx.setBoxes((prev) => this.mutate(prev.map((b: any) => {\r\n      const { resultText, error, ...rest } = b || {};\r\n      return { ...rest };\r\n    })));\r\n  }\r\n  undo(ctx: CommandCtx): void {\r\n    if (!this.beforeBoxes) return;\r\n    // Restore structural/content state while preserving current UI-only fields like mode when possible\r\n    ctx.setBoxes((prev) => {\r\n      const idToPrev: Map<string, any> = new Map(prev.map((b: any) => [b.id, b]));\r\n      const restored = this.beforeBoxes!.map((snap: any) => {\r\n        const prevBox = idToPrev.get(snap.id);\r\n        const mode = prevBox ? prevBox.mode : 'render';\r\n        const { resultText, error, ...rest } = snap || {};\r\n        // For math boxes, ensure raw is clean for editing (use src as raw when in edit mode)\r\n        if (rest.renderAsMath && rest.src && mode === 'edit') {\r\n          return { ...rest, mode, raw: rest.src };\r\n        }\r\n        return { ...rest, mode };\r\n      });\r\n      return restored;\r\n    });\r\n  }\r\n\r\n  merge(next: Command): Command | undefined {\r\n    if (!(next instanceof EditBoxCommand)) return undefined;\r\n    if (!['move','resize','nudge'].includes(this.kind)) return undefined;\r\n    if (next.kind !== this.kind) return undefined;\r\n    // Require same target ids to coalesce\r\n    const a = this.targetIds; const b = next.targetIds;\r\n    const sameTargets = (() => {\r\n      if (!a && !b) return true;\r\n      if (!a || !b) return false;\r\n      if (a.size !== b.size) return false;\r\n      for (const id of a) if (!b.has(id)) return false;\r\n      return true;\r\n    })();\r\n    if (!sameTargets) return undefined;\r\n    const within = (next.ts - this.ts) <= 600; // coalesce window\r\n    if (!within) return undefined;\r\n    // Keep original before snapshot; use next.mutate and timestamp; preserve targetIds\r\n    return new EditBoxCommand(next.mutate, this.kind as EditKind, this.targetIds, next.ts, this.beforeBoxes);\r\n  }\r\n}\r\n\r\n\r\n","size_bytes":3158},"src/history/commands/sheet/PasteCommand.ts":{"content":"import type { Command, CommandCtx } from '../../Command';\r\n\r\n// Sparse grid paste: applies a rectangular clipboard grid at (startR, startC)\r\nexport class PasteCommand implements Command {\r\n  name = 'Paste';\r\n  scope: 'sheet' = 'sheet';\r\n  private before: Array<{ r: number; c: number; value: string; format?: any }> = [];\r\n\r\n  constructor(private startR: number, private startC: number, private grid: string[][]) {}\r\n\r\n  do(ctx: CommandCtx): void {\r\n    if (this.before.length === 0) {\r\n      for (let dr = 0; dr < this.grid.length; dr += 1) {\r\n        for (let dc = 0; dc < this.grid[dr].length; dc += 1) {\r\n          const r = this.startR + dr;\r\n          const c = this.startC + dc;\r\n          this.before.push({ r, c, ...ctx.getCell(r, c) });\r\n        }\r\n      }\r\n    }\r\n    for (let dr = 0; dr < this.grid.length; dr += 1) {\r\n      for (let dc = 0; dc < this.grid[dr].length; dc += 1) {\r\n        const r = this.startR + dr;\r\n        const c = this.startC + dc;\r\n        ctx.setCell(r, c, this.grid[dr][dc]);\r\n      }\r\n    }\r\n  }\r\n\r\n  undo(ctx: CommandCtx): void {\r\n    for (let i = 0; i < this.before.length; i += 1) {\r\n      const { r, c, value, format } = this.before[i];\r\n      ctx.setCell(r, c, value, format);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n","size_bytes":1240},"src/history/commands/sheet/SetCellValueCommand.ts":{"content":"import type { Command, CommandCtx } from '../../Command';\r\n\r\nexport class SetCellValueCommand implements Command {\r\n  name = 'SetCellValue';\r\n  scope: 'sheet' = 'sheet';\r\n  private before: { value: string; format?: any } | null = null;\r\n\r\n  private r: number;\r\n  private c: number;\r\n  private nextValue: string;\r\n  private nextFormat?: any;\r\n\r\n  constructor(r: number, c: number, nextValue: string, nextFormat?: any) {\r\n    this.r = r; this.c = c; this.nextValue = nextValue; this.nextFormat = nextFormat;\r\n  }\r\n\r\n  do(ctx: CommandCtx): void {\r\n    if (!this.before) this.before = ctx.getCell(this.r, this.c);\r\n    ctx.setCell(this.r, this.c, this.nextValue, this.nextFormat);\r\n  }\r\n\r\n  undo(ctx: CommandCtx): void {\r\n    if (!this.before) return;\r\n    ctx.setCell(this.r, this.c, this.before.value, this.before.format);\r\n  }\r\n\r\n  merge(next: Command): Command | undefined {\r\n    if (!(next instanceof SetCellValueCommand)) return undefined;\r\n    if (next.r !== this.r || next.c !== this.c) return undefined;\r\n    // Merge typing in same cell\r\n    return new SetCellValueCommand(this.r, this.c, next.nextValue, next.nextFormat);\r\n  }\r\n}\r\n\r\n\r\n","size_bytes":1142},"src/history/ctx.ts":{"content":"import type { CommandCtx } from './Command';\r\n\r\nexport type GridAccessor = {\r\n  get: (r: number, c: number) => { value: string; format?: any };\r\n  set: (r: number, c: number, value: string, format?: any) => void;\r\n};\r\n\r\nexport type BoxesAccessor = {\r\n  get: () => any[];\r\n  // Accept either a full array or a functional updater(prev)\r\n  set: (next: any[] | ((prev: any[]) => any[])) => void;\r\n};\r\n\r\nexport class AppCommandCtx implements CommandCtx {\r\n  private grid: GridAccessor;\r\n  private boxes: BoxesAccessor;\r\n  constructor(grid: GridAccessor, boxes: BoxesAccessor) {\r\n    this.grid = grid; this.boxes = boxes;\r\n  }\r\n\r\n  getCell(r: number, c: number) { return this.grid.get(r, c); }\r\n  setCell(r: number, c: number, value: string, format?: any) { this.grid.set(r, c, value, format); }\r\n\r\n  getBoxes() { return this.boxes.get(); }\r\n  setBoxes(next: any[] | ((prev: any[]) => any[])) { this.boxes.set(next as any); }\r\n}\r\n\r\n\r\n","size_bytes":928},"src/history/debug/MockCtx.ts":{"content":"import type { CommandCtx } from '../Command';\r\n\r\nexport class MockCtx implements CommandCtx {\r\n  private boxes: any[] = [];\r\n  constructor(initial: any[] = []) { this.boxes = initial.map(b => ({ ...b })); }\r\n  getCell() { return { value: '' }; }\r\n  setCell() {}\r\n  getBoxes() { return this.boxes.map(b => ({ ...b })); }\r\n  setBoxes(next: any[] | ((prev: any[]) => any[])) {\r\n    const computed = typeof next === 'function' ? (next as any)(this.boxes) : next;\r\n    this.boxes = computed.map((b: any) => ({ ...b }));\r\n  }\r\n}\r\n\r\n\r\n","size_bytes":528},"src/history/debug/SimpleHistoryRef.ts":{"content":"import type { Command, CommandCtx } from '../Command';\r\n\r\nexport class SimpleHistoryRef {\r\n  private undoStack: Command[] = [];\r\n  private redoStack: Command[] = [];\r\n  private txn: { name: string; cmds: Command[] } | null = null;\r\n  private performingUndoRedo = false;\r\n  constructor(private ctx: CommandCtx) {}\r\n\r\n  beginTransaction(name: string) {\r\n    if (!this.txn) this.txn = { name, cmds: [] };\r\n  }\r\n  commit() {\r\n    if (!this.txn) return;\r\n    const cmds = this.txn.cmds;\r\n    this.txn = null;\r\n    if (cmds.length === 0) return;\r\n    const compound: Command = {\r\n      name: `Txn:${cmds[0].name}`,\r\n      scope: 'report',\r\n      do: (ctx) => { cmds.forEach(c => c.do(ctx)); },\r\n      undo: (ctx) => { for (let i = cmds.length - 1; i >= 0; i -= 1) cmds[i].undo(ctx); },\r\n    };\r\n    this.undoStack.push(compound);\r\n    this.redoStack = [];\r\n  }\r\n  rollback() {\r\n    if (!this.txn) return;\r\n    for (let i = this.txn.cmds.length - 1; i >= 0; i -= 1) {\r\n      this.txn.cmds[i].undo(this.ctx);\r\n    }\r\n    this.txn = null;\r\n  }\r\n  push(cmd: Command) {\r\n    if (this.performingUndoRedo) return;\r\n    cmd.do(this.ctx);\r\n    if (this.txn) { this.txn.cmds.push(cmd); return; }\r\n    const last = this.undoStack[this.undoStack.length - 1];\r\n    if (last && last.merge) {\r\n      const merged = last.merge(cmd);\r\n      if (merged) { this.undoStack[this.undoStack.length - 1] = merged; this.redoStack = []; return; }\r\n    }\r\n    this.undoStack.push(cmd);\r\n    this.redoStack = [];\r\n  }\r\n  undoOnce() {\r\n    const c = this.undoStack.pop(); if (!c) return;\r\n    this.performingUndoRedo = true; try { c.undo(this.ctx); } finally { this.performingUndoRedo = false; }\r\n    this.redoStack.push(c);\r\n  }\r\n  redoOnce() {\r\n    const c = this.redoStack.pop(); if (!c) return;\r\n    this.performingUndoRedo = true; try { c.do(this.ctx); } finally { this.performingUndoRedo = false; }\r\n    this.undoStack.push(c);\r\n  }\r\n  canUndo() { return (this.txn ? this.txn.cmds.length > 0 : false) || this.undoStack.length > 0; }\r\n  canRedo() { return this.redoStack.length > 0; }\r\n  debugStacks() { return { undoLen: this.undoStack.length, redoLen: this.redoStack.length }; }\r\n}\r\n\r\n\r\n","size_bytes":2159},"src/history/debug/commands/EditBoxCommand.ts":{"content":"import type { Command, CommandCtx } from '../../Command';\r\n\r\ntype EditKind = 'edit' | 'add' | 'remove' | 'move' | 'resize' | 'nudge';\r\n\r\nexport class EditBoxCommand implements Command {\r\n  name = 'EditBox';\r\n  scope: 'report' = 'report';\r\n  private before: any[] | null = null;\r\n  private ts: number;\r\n  private mutate!: (boxes: any[]) => any[];\r\n  private kind!: EditKind;\r\n  constructor(mutate: (boxes: any[]) => any[], kind: EditKind = 'edit', private targetIds?: Set<string>, ts?: number) {\r\n    this.mutate = mutate as any;\r\n    this.kind = kind;\r\n    this.ts = ts ?? Date.now();\r\n  }\r\n  do(ctx: CommandCtx) {\r\n    if (!this.before) this.before = ctx.getBoxes().map(b => ({ ...b }));\r\n    ctx.setBoxes((prev) => this.mutate(prev.map(b => ({ ...b }))));\r\n  }\r\n  undo(ctx: CommandCtx) {\r\n    if (!this.before) return;\r\n    const snap = this.before.map(b => ({ ...b }));\r\n    ctx.setBoxes(() => snap);\r\n  }\r\n  merge(next: Command) {\r\n    if (!(next instanceof EditBoxCommand)) return undefined;\r\n    if (!['move','resize','nudge'].includes(this.kind)) return undefined;\r\n    if (next.kind !== this.kind) return undefined;\r\n    const a = this.targetIds; const b = next.targetIds;\r\n    const same = (!a && !b) || (a && b && a.size === b.size && Array.from(a).every(id => b.has(id)));\r\n    if (!same) return undefined;\r\n    if ((next.ts - this.ts) > 600) return undefined;\r\n    return new EditBoxCommand(next.mutate, this.kind, this.targetIds, next.ts);\r\n  }\r\n}\r\n\r\n\r\n","size_bytes":1466},"src/history/debug/historyHarness.test.ts":{"content":"import { describe, it, expect } from 'vitest';\r\nimport { History } from '../History';\r\nimport { SimpleHistoryRef } from './SimpleHistoryRef';\r\nimport { MockCtx } from './MockCtx';\r\nimport { EditBoxCommand as RealEdit } from '../commands/report/EditBoxCommand';\r\nimport { EditBoxCommand as RefEdit } from './commands/EditBoxCommand';\r\n\r\nfunction box(id: string, x = 0, y = 0) { return { id, x, y, z: 1, kind: 'calc', mode: 'render' as const, raw: '' }; }\r\n\r\ndescribe('History parity (real vs reference)', () => {\r\n  it('push -> undo -> redo symmetry', () => {\r\n    const init = [box('a'), box('b')];\r\n    const ctxReal = new MockCtx(init);\r\n    const ctxRef = new MockCtx(init);\r\n    const H = new History(ctxReal);\r\n    const R = new SimpleHistoryRef(ctxRef);\r\n\r\n    // Add\r\n    H.push(new RealEdit((prev) => [...prev, box('c')], 'add', new Set(['c'])));\r\n    R.push(new RefEdit((prev) => [...prev, box('c')], 'add', new Set(['c'])));\r\n    expect(ctxReal.getBoxes()).toEqual(ctxRef.getBoxes());\r\n\r\n    // Move\r\n    H.push(new RealEdit((prev) => prev.map(b => b.id === 'c' ? { ...b, x: 10, y: 5 } : b), 'move', new Set(['c'])));\r\n    R.push(new RefEdit((prev) => prev.map(b => b.id === 'c' ? { ...b, x: 10, y: 5 } : b), 'move', new Set(['c'])));\r\n    expect(ctxReal.getBoxes()).toEqual(ctxRef.getBoxes());\r\n\r\n    // Undo twice\r\n    H.undoOnce(); R.undoOnce();\r\n    expect(ctxReal.getBoxes()).toEqual(ctxRef.getBoxes());\r\n    H.undoOnce(); R.undoOnce();\r\n    expect(ctxReal.getBoxes()).toEqual(ctxRef.getBoxes());\r\n\r\n    // Redo twice\r\n    H.redoOnce(); R.redoOnce();\r\n    expect(ctxReal.getBoxes()).toEqual(ctxRef.getBoxes());\r\n    H.redoOnce(); R.redoOnce();\r\n    expect(ctxReal.getBoxes()).toEqual(ctxRef.getBoxes());\r\n  });\r\n\r\n  it('redo cleared on new push after undo', () => {\r\n    const ctxReal = new MockCtx([box('a')]);\r\n    const ctxRef = new MockCtx([box('a')]);\r\n    const H = new History(ctxReal);\r\n    const R = new SimpleHistoryRef(ctxRef);\r\n    H.push(new RealEdit((p)=>[...p, box('b')], 'add', new Set(['b'])));\r\n    R.push(new RefEdit((p)=>[...p, box('b')], 'add', new Set(['b'])));\r\n    H.undoOnce(); R.undoOnce();\r\n    H.push(new RealEdit((p)=>p.map(b=>b.id==='a'?{...b,x:1}:b), 'move', new Set(['a'])));\r\n    R.push(new RefEdit((p)=>p.map(b=>b.id==='a'?{...b,x:1}:b), 'move', new Set(['a'])));\r\n    expect(H.canRedo()).toBe(false);\r\n    expect(R.canRedo()).toBe(false);\r\n    expect(ctxReal.getBoxes()).toEqual(ctxRef.getBoxes());\r\n  });\r\n});\r\n\r\n\r\n","size_bytes":2466},"src/history/history.state.test.ts":{"content":"import { describe, it, expect } from 'vitest';\r\nimport { History } from './History';\r\nimport { AppCommandCtx } from './ctx';\r\nimport { SetCellValueCommand } from './commands/sheet/SetCellValueCommand';\r\n\r\n// Minimal grid/boxes accessors for History ctx\r\nfunction makeCtx() {\r\n  const data: string[][] = Array.from({ length: 2 }, () => Array(2).fill(''));\r\n  const grid = {\r\n    get: (r: number, c: number) => ({ value: data[r]?.[c] ?? '' }),\r\n    set: (r: number, c: number, value: string) => { if (!data[r]) return; data[r][c] = value; },\r\n  };\r\n  const boxes = {\r\n    get: () => [] as any[],\r\n    set: (_next: any) => {},\r\n  };\r\n  return new AppCommandCtx(grid, boxes);\r\n}\r\n\r\ndescribe('History state transitions', () => {\r\n  it('push -> canUndo true; undo -> canRedo true', () => {\r\n    const ctx = makeCtx();\r\n    const h = new History(ctx);\r\n\r\n    expect(h.canUndo()).toBe(false);\r\n    expect(h.canRedo()).toBe(false);\r\n\r\n    h.push(new SetCellValueCommand(0, 0, 'A'));\r\n    expect(h.canUndo()).toBe(true);\r\n    expect(h.canRedo()).toBe(false);\r\n\r\n    h.undoOnce();\r\n    expect(h.canUndo()).toBe(false);\r\n    expect(h.canRedo()).toBe(true);\r\n  });\r\n});\r\n\r\n\r\n","size_bytes":1162},"src/history/proxy.ts":{"content":"import type { History } from './History';\r\n\r\ntype HistoryLike = {\r\n  push: (...args: any[]) => void;\r\n  undoOnce: () => void;\r\n  redoOnce: () => void;\r\n  beginTransaction: (name: string) => void;\r\n  commit: () => void;\r\n  rollback: () => void;\r\n  canUndo: () => boolean;\r\n  canRedo: () => boolean;\r\n  onChange?: (cb: () => void) => () => void;\r\n  debugStacks?: () => { undo: string[]; redo: string[]; undoLen: number; redoLen: number; txnOpen: boolean };\r\n};\r\n\r\nexport type HistoryProxy = {\r\n  push: (...args: any[]) => void;\r\n  undoOnce: () => void;\r\n  redoOnce: () => void;\r\n  beginTransaction: (name: string) => void;\r\n  commit: () => void;\r\n  rollback: () => void;\r\n  canUndo: () => boolean;\r\n  canRedo: () => boolean;\r\n  isReady: () => boolean;\r\n  setReal: (h: HistoryLike) => void;\r\n  onChange: (cb: () => void) => () => void;\r\n  debugStacks: () => { undo: string[]; redo: string[]; undoLen: number; redoLen: number; txnOpen: boolean };\r\n};\r\n\r\nexport function createHistoryProxy(): HistoryProxy {\r\n  let real: HistoryLike | null = null;\r\n  let warned = false;\r\n  const warn = () => {\r\n    if (warned) return;\r\n    warned = true;\r\n    // eslint-disable-next-line no-console\r\n    console.warn('[history] called before ready; no-op');\r\n    // reset after a short delay to avoid spamming\r\n    setTimeout(() => { warned = false; }, 500);\r\n  };\r\n  const guard = <T extends (...args: any[]) => any>(fn: (h: HistoryLike, ...args: any[]) => ReturnType<T>) =>\r\n    ((...args: any[]) => {\r\n      if (!real) { warn(); return undefined as any; }\r\n      return fn(real, ...args);\r\n    });\r\n  return {\r\n    push: guard((h, cmd) => h.push(cmd)),\r\n    undoOnce: guard((h) => h.undoOnce()),\r\n    redoOnce: guard((h) => h.redoOnce()),\r\n    beginTransaction: guard((h, name: string) => h.beginTransaction(name)),\r\n    commit: guard((h) => h.commit()),\r\n    rollback: guard((h) => h.rollback()),\r\n    canUndo: () => (real ? real.canUndo() : false),\r\n    canRedo: () => (real ? real.canRedo() : false),\r\n    isReady: () => !!real,\r\n    setReal: (h: HistoryLike) => { real = h; },\r\n    onChange: (cb: () => void) => {\r\n      if (!real || !real.onChange) { warn(); return () => {}; }\r\n      return real.onChange(cb);\r\n    },\r\n    debugStacks: () => {\r\n      if (!real || !real.debugStacks) { warn(); return { undo: [], redo: [], undoLen: 0, redoLen: 0, txnOpen: false }; }\r\n      return real.debugStacks();\r\n    },\r\n  };\r\n}\r\n\r\n\r\n","size_bytes":2411},"src/index.css":{"content":":root {\n  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;\n  line-height: 1.5;\n  font-weight: 400;\n\n  color-scheme: light dark;\n  color: rgba(255, 255, 255, 0.87);\n  background-color: #242424;\n\n  font-synthesis: none;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\na {\n  font-weight: 500;\n  color: #646cff;\n  text-decoration: inherit;\n}\na:hover {\n  color: #535bf2;\n}\n\nbody {\n  margin: 0;\n  display: flex;\n  place-items: center;\n  min-width: 320px;\n  min-height: 100vh;\n}\n\nh1 {\n  font-size: 3.2em;\n  line-height: 1.1;\n}\n\nbutton {\n  border-radius: 8px;\n  border: 1px solid transparent;\n  padding: 0.6em 1.2em;\n  font-size: 1em;\n  font-weight: 500;\n  font-family: inherit;\n  background-color: #1a1a1a;\n  cursor: pointer;\n  transition: border-color 0.25s;\n}\nbutton:hover {\n  border-color: #646cff;\n}\nbutton:focus,\nbutton:focus-visible {\n  outline: 4px auto -webkit-focus-ring-color;\n}\n\n@media (prefers-color-scheme: light) {\n  :root {\n    color: #213547;\n    background-color: #ffffff;\n  }\n  a:hover {\n    color: #747bff;\n  }\n  button {\n    background-color: #f9f9f9;\n  }\n}\n\n","size_bytes":1155},"src/input/hotkeys.test.tsx":{"content":"import { describe, it, expect, vi } from 'vitest';\r\nimport { bindGlobalHotkeys } from './hotkeys';\r\n\r\nfunction dispatchKey(key: string, init: Partial<KeyboardEvent> = {}) {\r\n  const e = new KeyboardEvent('keydown', { key, bubbles: true, cancelable: true, ...init } as any);\r\n  const prevent = vi.fn(); const stop = vi.fn();\r\n  Object.defineProperty(e, 'preventDefault', { value: prevent });\r\n  Object.defineProperty(e, 'stopPropagation', { value: stop });\r\n  window.dispatchEvent(e);\r\n  return { prevent, stop };\r\n}\r\n\r\ndescribe('global hotkeys', () => {\r\n  it('handles undo/redo chords with preventDefault', () => {\r\n    const history = { undoOnce: vi.fn(), redoOnce: vi.fn() };\r\n    const unbind = bindGlobalHotkeys({ history, setTool: () => {}, addBoxAtCenter: () => {}, isEditingInApp: () => false });\r\n    const u = dispatchKey('z', { ctrlKey: true });\r\n    expect(history.undoOnce).toHaveBeenCalledTimes(1);\r\n    expect(u.prevent).toHaveBeenCalled();\r\n    const r1 = dispatchKey('z', { ctrlKey: true, shiftKey: true });\r\n    expect(history.redoOnce).toHaveBeenCalledTimes(1);\r\n    expect(r1.prevent).toHaveBeenCalled();\r\n    const r2 = dispatchKey('y', { ctrlKey: true });\r\n    expect(history.redoOnce).toHaveBeenCalledTimes(2);\r\n    expect(r2.prevent).toHaveBeenCalled();\r\n    // Plain z -> undo, plain r -> redo\r\n    const uPlain = dispatchKey('z');\r\n    expect(history.undoOnce).toHaveBeenCalledTimes(2);\r\n    expect(uPlain.prevent).toHaveBeenCalled();\r\n    const rPlain = dispatchKey('r');\r\n    expect(history.redoOnce).toHaveBeenCalledTimes(3);\r\n    expect(rPlain.prevent).toHaveBeenCalled();\r\n    unbind();\r\n  });\r\n\r\n  it('ignores plain letter hotkeys in inputs', () => {\r\n    const history = { undoOnce: vi.fn(), redoOnce: vi.fn() };\r\n    const unbind = bindGlobalHotkeys({ history, setTool: vi.fn(), addBoxAtCenter: vi.fn(), isEditingInApp: () => false });\r\n    const input = document.createElement('input');\r\n    document.body.appendChild(input);\r\n    input.focus();\r\n    const r = dispatchKey('a');\r\n    expect((unbind as any)).toBeTruthy();\r\n    expect(r.prevent).not.toHaveBeenCalled();\r\n    document.body.removeChild(input);\r\n    unbind();\r\n  });\r\n});\r\n\r\n\r\n","size_bytes":2175},"src/input/hotkeys.ts":{"content":"export type HistoryLike = {\r\n  undoOnce: () => void;\r\n  redoOnce: () => void;\r\n};\r\n\r\nexport type HotkeyDeps = {\r\n  history: HistoryLike;\r\n  setTool: (tool: 'select' | 'create') => void;\r\n  addBoxAtCenter: () => void;\r\n  isEditingInApp: () => boolean;\r\n};\r\n\r\nexport const isUndo = (e: KeyboardEvent) => (e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'z';\r\nexport const isRedo = (e: KeyboardEvent) => (e.ctrlKey || e.metaKey) && ((e.shiftKey && e.key.toLowerCase() === 'z') || e.key.toLowerCase() === 'y');\r\nexport const isPlain = (e: KeyboardEvent, k: string) => !e.ctrlKey && !e.metaKey && !e.altKey && e.key.toLowerCase() === k;\r\n\r\nexport function shouldIgnoreTarget(target: EventTarget | null, isEditingInApp: () => boolean): boolean {\r\n  const el = target as HTMLElement | null;\r\n  if (!el) return false;\r\n  const tag = el.tagName?.toLowerCase();\r\n  const isFormField = tag === 'input' || tag === 'textarea' || tag === 'select' || (el as any).isContentEditable;\r\n  if (!isFormField) return false;\r\n  // Allow app-level handling when editing is owned by History (e.g., report box edit)\r\n  return !isEditingInApp();\r\n}\r\n\r\nexport function bindGlobalHotkeys(deps: HotkeyDeps): () => void {\r\n  const handler = (e: KeyboardEvent) => {\r\n    const ignore = shouldIgnoreTarget(e.target, deps.isEditingInApp);\r\n    // Undo/Redo\r\n    if (!ignore && (isUndo(e) || isPlain(e, 'z'))) {\r\n      e.preventDefault(); e.stopPropagation(); deps.history.undoOnce(); return;\r\n    }\r\n    if (!ignore && (isRedo(e) || isPlain(e, 'r'))) {\r\n      e.preventDefault(); e.stopPropagation(); deps.history.redoOnce(); return;\r\n    }\r\n    // Tool hotkeys\r\n    if (!ignore && isPlain(e, 'v')) {\r\n      e.preventDefault(); e.stopPropagation(); deps.setTool('select'); return;\r\n    }\r\n    if (!ignore && isPlain(e, 'a')) {\r\n      e.preventDefault(); e.stopPropagation(); deps.setTool('create'); deps.addBoxAtCenter(); return;\r\n    }\r\n  };\r\n  window.addEventListener('keydown', handler, { capture: true });\r\n  return () => window.removeEventListener('keydown', handler, true as any);\r\n}\r\n\r\n\r\n","size_bytes":2079},"src/lib/text/normalize.test.ts":{"content":"import { describe, it, expect } from 'vitest';\r\nimport { normalizeForParser } from './normalize';\r\n\r\ndescribe('normalizeForParser', () => {\r\n  it('converts unicode spaces and inserts space before units', () => {\r\n    const nbsp = '5\\u00A0in + 3in = 8\\u00A0in';\r\n    expect(normalizeForParser(nbsp)).toBe('5 in + 3 in = 8 in');\r\n  });\r\n\r\n  it('handles numbers with commas/decimals', () => {\r\n    expect(normalizeForParser('12,500kN')).toBe('12,500 kN');\r\n    expect(normalizeForParser('3.5psi')).toBe('3.5 psi');\r\n  });\r\n\r\n  it('collapses multiple spaces and trims', () => {\r\n    expect(normalizeForParser('  8   in  ')).toBe('8 in');\r\n  });\r\n});\r\n\r\n\r\n","size_bytes":651},"src/lib/text/normalize.ts":{"content":"// Canonicalize editor text so parsing is stable across typing, paste, undo/redo.\n\nconst UNICODE_SPACES = /[\\u00A0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/g; // nbsp..ideographic\nconst ZERO_WIDTH = /[\\u200B-\\u200D\\uFEFF]/g; // zwsp, zwnj, zwj, bom\n\n// Extend units as needed for your domain.\n// Define UNIT as a plain alternation string (no capturing parens) to avoid nested capture groups\nexport const UNIT = 'in|ft|yd|mm|cm|m|km|mil|N|kN|lb|lbs|kip|Pa|kPa|MPa|GPa|psi|psf|ksi|deg|rad';\n// number + optional spaces + (capture unit) + word boundary\nconst NUM_UNIT = new RegExp(`(\\\\d(?:[\\\\d.,]*))\\\\s*(?:(${UNIT}))(\\\\b)`, 'gi');\n\nexport function normalizeForParser(raw: string): string {\n  if (!raw) return '';\n  let s = raw\n    .replace(ZERO_WIDTH, '')\n    .replace(UNICODE_SPACES, ' ')\n    .replace(/\\s+/g, ' '); // collapse spaces\n\n  // Ensure there's a space between number and unit\n  s = s.replace(NUM_UNIT, '$1 $2$3');\n\n  // Convert all multiplication symbols to *\n  s = s.replace(/\\\\cdot|\\\\times|·|×/g, '*');\n  \n  // Convert all division symbols to /\n  s = s.replace(/\\\\div|÷/g, '/');\n  \n  // Convert Unicode minus to regular minus\n  s = s.replace(/−/g, '-');\n  \n  // Optional tidy around equals\n  s = s.replace(/\\s*=\\s*/g, ' = ');\n  return s.trim();\n}\n\n// Collapse accidental duplicate unit tokens like \"in in\" or \"inin\" into a single unit.\nexport function collapseDuplicateUnits(raw: string): string {\n  if (!raw) return '';\n  let s = raw;\n  // Replace repeated unit tokens after a number: e.g., 5 inin, 5 in in\n  const DUP_AFTER_NUM = new RegExp(`(\\\\d(?:[\\\\d.,]*))\\\\s*(?:(${UNIT}))\\\\s*\\\\2\\\\b`, 'gi');\n  for (let i = 0; i < 3; i += 1) {\n    const next = s.replace(DUP_AFTER_NUM, '$1 $2');\n    if (next === s) break; s = next;\n  }\n  // Replace standalone repeated units: e.g., in in -> in\n  const DUP_LONE = new RegExp(`(\\\\b)(?:(${UNIT}))\\\\s*\\\\2\\\\b`, 'gi');\n  for (let i = 0; i < 3; i += 1) {\n    const next = s.replace(DUP_LONE, '$1$2');\n    if (next === s) break; s = next;\n  }\n  return s;\n}\n\n\n","size_bytes":2005},"src/main.tsx":{"content":"import React, { StrictMode, useEffect } from 'react'\nimport { createRoot } from 'react-dom/client'\nimport './index.css'\nimport 'katex/dist/katex.min.css'\nimport App from './App'\nimport ErrorBoundary from './components/ErrorBoundary'\nimport { installCrashOverlay, recordBootMark, signalAppMounted } from './debug/CrashOverlay'\n\n// Global error logging during boot to catch silent failures\nfunction installGlobalErrorLogging() {\n  if ((window as any).__errInstalled) return;\n  (window as any).__errInstalled = true;\n  window.onerror = (msg, src, line, col, err) => {\n    // eslint-disable-next-line no-console\n    console.error('window.onerror:', { msg, src, line, col, err });\n  };\n  window.onunhandledrejection = (ev) => {\n    // eslint-disable-next-line no-console\n    console.error('window.onunhandledrejection:', ev.reason || ev);\n  };\n}\n\nif (import.meta.env.DEV) {\n  installCrashOverlay({ mountTimeoutMs: 2000 });\n  recordBootMark('[BOOT] entry bundle executed');\n}\n\nfunction Boot() {\n  useEffect(() => { installGlobalErrorLogging(); }, []);\n  return (\n    <StrictMode>\n      <ErrorBoundary>\n        <App />\n      </ErrorBoundary>\n    </StrictMode>\n  );\n}\n\nfunction safeRender() {\n  try {\n    recordBootMark('[BOOT] createRoot');\n    const root = createRoot(document.getElementById('root')!);\n    recordBootMark('[BOOT] render <App/>' );\n    root.render(<Boot />);\n    recordBootMark('[BOOT] render complete');\n    signalAppMounted();\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error('Root render failed:', e);\n  }\n}\n\nsafeRender();\n","size_bytes":1564},"src/notebook/BlockEditor.tsx":{"content":"import React from \"react\";\r\n\r\ntype Props = {\r\n  value: string;\r\n  onChange: (next: string) => void;\r\n  placeholder?: string;\r\n};\r\n\r\nexport default function BlockEditor({ value, onChange, placeholder }: Props) {\r\n  return (\r\n    <textarea\r\n      value={value}\r\n      onChange={(e) => onChange(e.target.value)}\r\n      placeholder={placeholder}\r\n      style={{\r\n        width: \"100%\",\r\n        minHeight: 80,\r\n        padding: 8,\r\n        boxSizing: \"border-box\",\r\n        background: \"#1f1f1f\",\r\n        color: \"#efefef\",\r\n        border: \"1px solid #4a4a4a\",\r\n        borderRadius: 4,\r\n        resize: \"vertical\",\r\n      }}\r\n    />\r\n  );\r\n} ","size_bytes":640},"src/notebook/BlockRenderer.tsx":{"content":"import React from \"react\";\r\n\r\ntype Props = { text: string; getCellDisplay?: (r: number, c: number) => string };\r\n\r\n// function indexToCol(n: number) {\r\n//   let s = \"\"; n += 1;\r\n//   while (n > 0) { const rem = (n - 1) % 26; s = String.fromCharCode(65 + rem) + s; n = Math.floor((n - 1) / 26); }\r\n//   return s;\r\n// }\r\n\r\nfunction colLabelToIndex(label: string): number {\r\n  let result = 0;\r\n  for (let i = 0; i < label.length; i += 1) {\r\n    const code = label.charCodeAt(i);\r\n    if (code < 65 || code > 90) return -1;\r\n    result = result * 26 + (code - 64);\r\n  }\r\n  return result - 1;\r\n}\r\n\r\n// Find cell refs like A1, AA10 in the text\r\nfunction findCellRefs(input: string): Array<{ start: number; end: number; r: number; c: number; label: string }> {\r\n  const results: Array<{ start: number; end: number; r: number; c: number; label: string }> = [];\r\n  const regex = /\\b([A-Z]+)([1-9][0-9]*)\\b/g;\r\n  let m: RegExpExecArray | null;\r\n  while ((m = regex.exec(input)) !== null) {\r\n    const col = m[1];\r\n    const row = m[2];\r\n    const c = colLabelToIndex(col);\r\n    const r = parseInt(row, 10) - 1;\r\n    if (c >= 0 && r >= 0) {\r\n      results.push({ start: m.index, end: m.index + m[0].length, r, c, label: `${col}${row}` });\r\n    }\r\n  }\r\n  return results;\r\n}\r\n\r\nexport default function BlockRenderer({ text, getCellDisplay }: Props) {\r\n  const refs = findCellRefs(text);\r\n  if (refs.length === 0) {\r\n    return (\r\n      <div\r\n        style={{\r\n          whiteSpace: \"pre-wrap\",\r\n          background: \"#262626\",\r\n          color: \"#efefef\",\r\n          border: \"1px solid #4a4a4a\",\r\n          borderRadius: 4,\r\n          padding: 8,\r\n        }}\r\n      >\r\n        {text}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  const parts: React.ReactNode[] = [];\r\n  let cursor = 0;\r\n  refs.forEach((ref, idx) => {\r\n    if (ref.start > cursor) {\r\n      parts.push(text.slice(cursor, ref.start));\r\n    }\r\n    const value = getCellDisplay ? getCellDisplay(ref.r, ref.c) : \"\";\r\n    parts.push(\r\n      <span key={`ref-${idx}`} className=\"cell-ref\" title={`${ref.label} = ${value}`} style={{ textDecoration: \"underline dotted\" }}>\r\n        {ref.label}\r\n      </span>\r\n    );\r\n    cursor = ref.end;\r\n  });\r\n  if (cursor < text.length) parts.push(text.slice(cursor));\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        whiteSpace: \"pre-wrap\",\r\n        background: \"#262626\",\r\n        color: \"#efefef\",\r\n        border: \"1px solid #4a4a4a\",\r\n        borderRadius: 4,\r\n        padding: 8,\r\n      }}\r\n    >\r\n      {parts}\r\n    </div>\r\n  );\r\n} ","size_bytes":2508},"src/notebook/NotebookView.tsx":{"content":"import React, { useMemo, useState, useEffect } from \"react\";\r\nimport type { NotebookDoc, NotebookBlock } from \"./notebookTypes\";\r\nimport BlockEditor from \"./BlockEditor\";\r\nimport BlockRenderer from \"./BlockRenderer\";\r\n\r\ntype Props = {\r\n  getCellDisplay?: (r: number, c: number) => string;\r\n};\r\n\r\nconst STORAGE_KEY = \"notebook:v1\";\r\n\r\nfunction createId(): string {\r\n  if (typeof crypto !== \"undefined\" && \"randomUUID\" in crypto) {\r\n    try { return (crypto as any).randomUUID(); } catch {}\r\n  }\r\n  return `b_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;\r\n}\r\n\r\nexport default function NotebookView({ getCellDisplay }: Props) {\r\n  const [doc, setDoc] = useState<NotebookDoc>({ blocks: [] });\r\n\r\n  // Load from localStorage on mount\r\n  useEffect(() => {\r\n    try {\r\n      const raw = localStorage.getItem(STORAGE_KEY);\r\n      if (raw) {\r\n        const parsed = JSON.parse(raw) as NotebookDoc;\r\n        if (parsed && Array.isArray(parsed.blocks)) {\r\n          setDoc({ blocks: parsed.blocks.map((b) => ({ id: String(b.id), kind: b.kind === \"math\" ? \"math\" : \"text\", text: String(b.text ?? \"\"), collapsed: Boolean(b.collapsed) })) });\r\n        }\r\n      }\r\n    } catch {\r\n      // ignore parse/load errors\r\n    }\r\n  }, []);\r\n\r\n  // Save to localStorage on change\r\n  useEffect(() => {\r\n    try {\r\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(doc));\r\n    } catch {\r\n      // ignore write errors\r\n    }\r\n  }, [doc]);\r\n\r\n  const addTextBlock = () => {\r\n    const newBlock: NotebookBlock = { id: createId(), kind: \"text\", text: \"\" };\r\n    setDoc((prev) => ({ blocks: [...prev.blocks, newBlock] }));\r\n  };\r\n\r\n  const deleteBlock = (id: string) => {\r\n    setDoc((prev) => ({ blocks: prev.blocks.filter((b) => b.id !== id) }));\r\n  };\r\n\r\n  const updateBlockText = (id: string, next: string) => {\r\n    setDoc((prev) => ({\r\n      blocks: prev.blocks.map((b) => (b.id === id ? { ...b, text: next } : b)),\r\n    }));\r\n  };\r\n\r\n  return (\r\n    <div style={{ maxWidth: 1200, margin: \"1rem auto\", padding: \"0 12px\" }}>\r\n      <div style={{ display: \"flex\", justifyContent: \"space-between\", alignItems: \"center\", marginBottom: 12 }}>\r\n        <h2 style={{ margin: 0 }}>Notebook</h2>\r\n        <button\r\n          type=\"button\"\r\n          onClick={addTextBlock}\r\n          style={{\r\n            padding: \"6px 12px\",\r\n            border: \"1px solid #4a4a4a\",\r\n            background: \"#1f1f1f\",\r\n            color: \"#efefef\",\r\n            cursor: \"pointer\",\r\n            borderRadius: 4,\r\n          }}\r\n        >\r\n          + Text Block\r\n        </button>\r\n      </div>\r\n\r\n      <div style={{ display: \"flex\", flexDirection: \"column\", gap: 16 }}>\r\n        {doc.blocks.map((block) => (\r\n          <div key={block.id} style={{ display: \"flex\", flexDirection: \"column\", gap: 8, border: \"1px solid #333\", borderRadius: 6, padding: 12, background: \"#1b1b1b\", boxShadow: \"0 1px 2px rgba(0,0,0,0.2)\" }}>\r\n            <div style={{ display: \"flex\", justifyContent: \"space-between\", alignItems: \"center\" }}>\r\n              <strong style={{ opacity: 0.9 }}>{block.kind === \"text\" ? \"Text\" : \"Math\"} Block</strong>\r\n              <button\r\n                type=\"button\"\r\n                onClick={() => deleteBlock(block.id)}\r\n                style={{\r\n                  padding: \"4px 8px\",\r\n                  border: \"1px solid #4a4a4a\",\r\n                  background: \"#1f1f1f\",\r\n                  color: \"#efefef\",\r\n                  cursor: \"pointer\",\r\n                  borderRadius: 4,\r\n                }}\r\n              >\r\n                Delete\r\n              </button>\r\n            </div>\r\n\r\n            <BlockEditor\r\n              value={block.text}\r\n              onChange={(next) => updateBlockText(block.id, next)}\r\n              placeholder={block.kind === \"text\" ? \"Type text...\" : \"Type math...\"}\r\n            />\r\n\r\n            <BlockRenderer text={block.text} getCellDisplay={getCellDisplay} />\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n} ","size_bytes":3970},"src/notebook/notebookTypes.ts":{"content":"export type NotebookBlock = { id: string; kind: \"text\" | \"math\"; text: string; collapsed?: boolean };\r\nexport type NotebookDoc = { blocks: NotebookBlock[] }; ","size_bytes":158},"src/referencing/a1.test.ts":{"content":"import { describe, it, expect } from 'vitest';\r\nimport { indexToCol, colLabelToIndex, parseAddress } from './a1';\r\n\r\ndescribe('A1 helpers', () => {\r\n  it('round-trips common columns', () => {\r\n    const labels = ['A','Z','AA','AZ','BA','ZZ','AAA'];\r\n    for (const label of labels) {\r\n      const c = colLabelToIndex(label);\r\n      expect(c).toBeGreaterThanOrEqual(0);\r\n      expect(indexToCol(c)).toBe(label);\r\n    }\r\n  });\r\n\r\n  it('parses A1 to rc correctly', () => {\r\n    expect(parseAddress('A1')).toEqual({ r: 0, c: 0 });\r\n    expect(parseAddress('Z10')).toEqual({ r: 9, c: 25 });\r\n    expect(parseAddress('AA2')).toEqual({ r: 1, c: 26 });\r\n    expect(parseAddress('invalid')).toBeNull();\r\n  });\r\n});\r\n\r\n\r\n","size_bytes":711},"src/referencing/a1.ts":{"content":"export function indexToCol(n: number) {\r\n  let s = \"\"; n += 1;\r\n  while (n > 0) { const rem = (n - 1) % 26; s = String.fromCharCode(65 + rem) + s; n = Math.floor((n - 1) / 26); }\r\n  return s;\r\n}\r\n\r\nexport function colLabelToIndex(label: string): number {\r\n  let result = 0;\r\n  for (let i = 0; i < label.length; i += 1) {\r\n    const code = label.charCodeAt(i);\r\n    if (code < 65 || code > 90) return -1; // not A-Z\r\n    result = result * 26 + (code - 64);\r\n  }\r\n  return result - 1;\r\n}\r\n\r\nexport function parseAddress(addr: string): { r: number; c: number } | null {\r\n  const trimmed = addr.trim().toUpperCase();\r\n  const match = /^([A-Z]+)([1-9][0-9]*)$/.exec(trimmed);\r\n  if (!match) return null;\r\n  const colPart = match[1];\r\n  const rowPart = match[2];\r\n  const c = colLabelToIndex(colPart);\r\n  const r = parseInt(rowPart, 10) - 1;\r\n  if (c < 0 || r < 0) return null;\r\n  return { r, c };\r\n} ","size_bytes":895},"src/referencing/insertTarget.ts":{"content":"export type InsertTarget = {\r\n  kind?: 'report' | 'sheet';\r\n  boxId?: string;\r\n  insert?: (text: string) => void;\r\n  // Optional rich API for sticky/cross-tab editing\r\n  getText?: () => string;\r\n  setText?: (next: string) => void;\r\n  getSelection?: () => { start: number; end: number } | null;\r\n  setSelection?: (sel: { start: number; end: number } | null) => void;\r\n  commit?: () => void;\r\n  cancel?: () => void;\r\n};\r\n\r\nexport type FallbackTarget = {\r\n  docId: string;\r\n  reportTabId?: string;\r\n  boxId: string;\r\n  append?: boolean; // default true\r\n};\r\n\r\nlet currentTarget: InsertTarget | null = null;\r\nlet stickyTarget: InsertTarget | null = null;\r\nlet fallbackTarget: FallbackTarget | null = null;\r\nconst listeners = new Set<() => void>();\r\n\r\nexport function setInsertTarget(t: InsertTarget | null, opts?: { sticky?: boolean }) {\r\n  if (opts?.sticky) {\r\n    stickyTarget = t;\r\n  } else {\r\n    currentTarget = t;\r\n  }\r\n  listeners.forEach((fn) => { try { fn(); } catch {} });\r\n}\r\n\r\nexport function getInsertTarget(): InsertTarget | null {\r\n  return currentTarget || stickyTarget;\r\n}\r\n\r\nexport function hasInsertTarget(): boolean {\r\n  return currentTarget != null || stickyTarget != null || fallbackTarget != null;\r\n}\r\n\r\nexport function insertText(text: string): boolean {\r\n  const target = currentTarget || stickyTarget;\r\n  if (target) {\r\n    try {\r\n      // Prefer rich API to honor caret/selection if available\r\n      if (target.getText && target.setText) {\r\n        const buf = target.getText();\r\n        let start = buf.length; let end = buf.length;\r\n        if (target.getSelection) {\r\n          const sel = target.getSelection();\r\n          if (sel) { start = sel.start; end = sel.end; }\r\n        }\r\n        const next = buf.slice(0, start) + text + buf.slice(end);\r\n        target.setText(next);\r\n        if (target.setSelection) target.setSelection({ start: start + text.length, end: start + text.length });\r\n        // Notify subscribers so UI can re-render bound Formula Bar\r\n        listeners.forEach((fn) => { try { fn(); } catch {} });\r\n        return true;\r\n      }\r\n      if (target.insert) { target.insert(text); return true; }\r\n      return false;\r\n    } catch { return false; }\r\n  }\r\n  if (fallbackTarget) {\r\n    try {\r\n      const { docId, boxId } = fallbackTarget;\r\n      const key = `reportCanvas:doc:${docId}`;\r\n      const raw = localStorage.getItem(key);\r\n      if (!raw) return false;\r\n      const parsed = JSON.parse(raw) as { boxes: any[] };\r\n      if (!parsed || !Array.isArray(parsed.boxes)) return false;\r\n      const boxes = parsed.boxes.map(b => ({ ...b }));\r\n      const idx = boxes.findIndex(b => String(b.id) === String(boxId));\r\n      if (idx < 0) return false;\r\n      const b = boxes[idx];\r\n      // Decide which field to edit: prefer src for math, else raw\r\n      if (b && b.src && b.renderAsMath) {\r\n        b.src = String(b.src || '') + text;\r\n        // Keep raw unchanged; it will be regenerated on next open\r\n      } else {\r\n        b.raw = String(b.raw || '') + text;\r\n      }\r\n      localStorage.setItem(key, JSON.stringify({ boxes }));\r\n      // Mark which box should open in edit on next load\r\n      localStorage.setItem(`reportCanvas:editing:${docId}`, String(boxId));\r\n      return true;\r\n    } catch { return false; }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function subscribeInsertTarget(listener: () => void): () => void {\r\n  listeners.add(listener);\r\n  return () => { listeners.delete(listener); };\r\n}\r\n\r\nexport function notifyInsertTargetChanged(): void {\r\n  listeners.forEach((fn) => { try { fn(); } catch {} });\r\n}\r\n\r\nexport function setFallbackInsertTarget(target: FallbackTarget | null) {\r\n  fallbackTarget = target;\r\n  listeners.forEach((fn) => { try { fn(); } catch {} });\r\n}\r\n\r\nexport function getFallbackTarget(): FallbackTarget | null { return fallbackTarget; }\r\n\r\n\r\n\r\n","size_bytes":3830},"src/referencing/names.ts":{"content":"export type Name = string;\nexport type Target = { kind: \"cell\" | \"block\"; ref: string };\n\n// Store for named references (cells/blocks)\nconst store = new Map<Name, Target>();\n\n// Store for variables and their values\nconst variableStore = new Map<string, number>();\n\n// Store for cell-to-variable mapping (which cell defines which variable)\nconst cellToVariablesStore = new Map<string, Set<string>>();\n\n// Store for variable-to-cell mapping (which cell defines each variable)\nconst variableToCellStore = new Map<string, string>();\n\nexport function defineName(name: Name, target: Target) {\n  store.set(name, target);\n}\n\nexport function resolveName(name: Name): Target | undefined {\n  return store.get(name);\n}\n\n// Variable storage functions\nexport function defineVariable(name: string, value: number) {\n  variableStore.set(name, value);\n}\n\n// Enhanced variable definition with cell tracking\nexport function defineVariableInCell(name: string, value: number, cellKey: string) {\n  // Clear old mapping if variable was defined elsewhere\n  const oldCell = variableToCellStore.get(name);\n  if (oldCell && oldCell !== cellKey) {\n    const oldVariables = cellToVariablesStore.get(oldCell);\n    if (oldVariables) {\n      oldVariables.delete(name);\n      if (oldVariables.size === 0) {\n        cellToVariablesStore.delete(oldCell);\n      }\n    }\n  }\n\n  // Store the variable value\n  variableStore.set(name, value);\n  \n  // Track variable-to-cell mapping\n  variableToCellStore.set(name, cellKey);\n  \n  // Track cell-to-variables mapping\n  let variables = cellToVariablesStore.get(cellKey);\n  if (!variables) {\n    variables = new Set();\n    cellToVariablesStore.set(cellKey, variables);\n  }\n  variables.add(name);\n}\n\nexport function resolveVariable(name: string): number | undefined {\n  return variableStore.get(name);\n}\n\nexport function hasVariable(name: string): boolean {\n  return variableStore.has(name);\n}\n\n// Get which cell defines a variable\nexport function getVariableDefiningCell(name: string): string | undefined {\n  return variableToCellStore.get(name);\n}\n\n// Get all variables defined by a cell\nexport function getVariablesDefinedByCell(cellKey: string): Set<string> {\n  return cellToVariablesStore.get(cellKey) || new Set();\n}\n\n// Clear all variables defined by a specific cell\nexport function clearVariablesInCell(cellKey: string) {\n  const variables = cellToVariablesStore.get(cellKey);\n  if (variables) {\n    // Remove each variable from the variable store and variable-to-cell mapping\n    for (const varName of variables) {\n      variableStore.delete(varName);\n      variableToCellStore.delete(varName);\n    }\n    // Clear the cell-to-variables mapping\n    cellToVariablesStore.delete(cellKey);\n  }\n}\n\nexport function clearVariables() {\n  variableStore.clear();\n  cellToVariablesStore.clear();\n  variableToCellStore.clear();\n}\n\n// Get all variables that depend on variables from a specific cell\nexport function getDependentVariables(cellKey: string): Set<string> {\n  const dependents = new Set<string>();\n  const cellVariables = cellToVariablesStore.get(cellKey);\n  \n  if (!cellVariables) return dependents;\n  \n  // Find all variables that might reference variables from this cell\n  for (const [varName, definingCell] of variableToCellStore) {\n    if (definingCell !== cellKey) {\n      // This variable is defined elsewhere, check if it might depend on our cell's variables\n      dependents.add(varName);\n    }\n  }\n  \n  return dependents;\n}","size_bytes":3443},"src/ui/Toolbar.tsx":{"content":"import React from \"react\";\r\n\r\ntype Props = {\r\n  onDelete?: () => void;\r\n  onDuplicate?: () => void;\r\n};\r\n\r\nexport default function Toolbar({ onDelete, onDuplicate }: Props) {\r\n  return (\r\n    <div style={{ display: \"flex\", gap: 8 }}>\r\n      <button\r\n        type=\"button\"\r\n        onClick={onDelete}\r\n        style={{ padding: \"4px 8px\", border: \"1px solid #4a4a4a\", background: \"#1f1f1f\", color: \"#efefef\", cursor: \"pointer\", borderRadius: 4 }}\r\n      >\r\n        Delete\r\n      </button>\r\n      <button\r\n        type=\"button\"\r\n        onClick={onDuplicate}\r\n        style={{ padding: \"4px 8px\", border: \"1px solid #4a4a4a\", background: \"#1f1f1f\", color: \"#efefef\", cursor: \"pointer\", borderRadius: 4 }}\r\n      >\r\n        Duplicate\r\n      </button>\r\n      <button\r\n        type=\"button\"\r\n        disabled\r\n        style={{ padding: \"4px 8px\", border: \"1px solid #4a4a4a\", background: \"#2b2b2b\", color: \"#888\", borderRadius: 4 }}\r\n      >\r\n        Change type\r\n      </button>\r\n    </div>\r\n  );\r\n} ","size_bytes":996},"src/vite-env.d.ts":{"content":"/// <reference types=\"vite/client\" />\n","size_bytes":38},"vite.config.ts":{"content":"import { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    host: '0.0.0.0',\n    port: 5000,\n    strictPort: true,\n    allowedHosts: ['localhost', '.replit.dev', '.repl.co'],\n    hmr: { \n      clientPort: 443, \n      protocol: 'wss' \n    }\n  },\n  preview: {\n    host: '0.0.0.0',\n    port: 5000\n  }\n})\n","size_bytes":387},"src/engine/variable-integration.test.ts":{"content":"import { describe, it, expect, beforeEach } from 'vitest';\nimport { evaluateCell, evaluate } from './eval';\nimport { defineVariableInCell, getVariableDefiningCell, clearVariablesInCell, resolveVariable, clearVariables } from '../referencing/names';\n\ndescribe('Spreadsheet Variable Integration', () => {\n  beforeEach(() => {\n    // Clear all variables before each test\n    clearVariables();\n  });\n\n  describe('Basic Variable Definition and Reference', () => {\n    it('should define variable in cell and reference from another cell', () => {\n      const grid = [\n        ['L = 5', '=L * 2'],\n        ['', '']\n      ];\n      \n      // Evaluate cell A1 (L = 5)\n      const resultA1 = evaluateCell(grid, 'L = 5', 0, 0);\n      expect(resultA1).toBe(5);\n      \n      // Check that the variable is mapped to the correct cell\n      expect(getVariableDefiningCell('L')).toBe('0:0');\n      \n      // Evaluate cell B1 (=L * 2) - should trigger evaluation of A1\n      const resultB1 = evaluateCell(grid, '=L * 2', 0, 1);\n      expect(resultB1).toBe(10);\n    });\n\n    it('should handle units in variable definitions', () => {\n      const grid = [\n        ['L = 5 ft', '=L * 2'],\n        ['', '']\n      ];\n      \n      const resultA1 = evaluateCell(grid, 'L = 5 ft', 0, 0);\n      expect(resultA1).toBe(5);\n      \n      const resultB1 = evaluateCell(grid, '=L * 2', 0, 1);\n      expect(resultB1).toBe(10);\n    });\n  });\n\n  describe('Variable-to-Variable Dependencies', () => {\n    it('should handle chained variable dependencies', () => {\n      const grid = [\n        ['L = 5', 'W = L * 2', '=W + L'],\n        ['', '', '']\n      ];\n      \n      // Define L = 5\n      const resultA1 = evaluateCell(grid, 'L = 5', 0, 0);\n      expect(resultA1).toBe(5);\n      \n      // Define W = L * 2 (depends on L)\n      const resultB1 = evaluateCell(grid, 'W = L * 2', 0, 1);\n      expect(resultB1).toBe(10);\n      \n      // Use both variables\n      const resultC1 = evaluateCell(grid, '=W + L', 0, 2);\n      expect(resultC1).toBe(15); // 10 + 5\n    });\n\n    it('should handle complex expression dependencies', () => {\n      const grid = [\n        ['Base = 10', 'Height = Base / 2', 'Area = Base * Height'],\n        ['', '', '']\n      ];\n      \n      evaluateCell(grid, 'Base = 10', 0, 0);\n      expect(resolveVariable('Base')).toBe(10);\n      \n      evaluateCell(grid, 'Height = Base / 2', 0, 1);\n      expect(resolveVariable('Height')).toBe(5);\n      \n      evaluateCell(grid, 'Area = Base * Height', 0, 2);\n      expect(resolveVariable('Area')).toBe(50);\n    });\n  });\n\n  describe('Cycle Detection', () => {\n    it('should detect direct variable cycles', () => {\n      const grid = [\n        ['A = B', 'B = A'],\n        ['', '']\n      ];\n      \n      expect(() => {\n        evaluateCell(grid, 'A = B', 0, 0);\n        evaluateCell(grid, 'B = A', 0, 1);\n      }).toThrow('#CYCLE!');\n    });\n\n    it('should detect indirect variable cycles', () => {\n      const grid = [\n        ['A = B', 'B = C', 'C = A'],\n        ['', '', '']\n      ];\n      \n      expect(() => {\n        evaluateCell(grid, 'A = B', 0, 0);\n        evaluateCell(grid, 'B = C', 0, 1);\n        evaluateCell(grid, 'C = A', 0, 2);\n      }).toThrow('#CYCLE!');\n    });\n\n    it('should detect cycles involving cell references and variables', () => {\n      const grid = [\n        ['A = A1', '=A + 1'],\n        ['', '']\n      ];\n      \n      expect(() => {\n        evaluateCell(grid, 'A = A1', 0, 0);\n        evaluateCell(grid, '=A + 1', 0, 1);\n      }).toThrow('#CYCLE!');\n    });\n  });\n\n  describe('Variable Redefinition', () => {\n    it('should handle variable redefinition in different cells', () => {\n      const grid = [\n        ['L = 5', ''],\n        ['L = 10', '=L * 2']\n      ];\n      \n      // Define L = 5 in A1\n      evaluateCell(grid, 'L = 5', 0, 0);\n      expect(getVariableDefiningCell('L')).toBe('0:0');\n      expect(resolveVariable('L')).toBe(5);\n      \n      // Redefine L = 10 in A2 (should override)\n      evaluateCell(grid, 'L = 10', 1, 0);\n      expect(getVariableDefiningCell('L')).toBe('1:0');\n      expect(resolveVariable('L')).toBe(10);\n      \n      // B2 should use the new value of L\n      const resultB2 = evaluateCell(grid, '=L * 2', 1, 1);\n      expect(resultB2).toBe(20);\n    });\n\n    it('should clean up old variable mappings when cell changes', () => {\n      const grid = [\n        ['L = 5', ''],\n        ['', '']\n      ];\n      \n      // Initially define L = 5\n      evaluateCell(grid, 'L = 5', 0, 0);\n      expect(getVariableDefiningCell('L')).toBe('0:0');\n      \n      // Clear variables in cell A1 (simulating cell value change)\n      clearVariablesInCell('0:0');\n      expect(getVariableDefiningCell('L')).toBeUndefined();\n      expect(resolveVariable('L')).toBeUndefined();\n    });\n  });\n\n  describe('Spreadsheet Recalculation Scenarios', () => {\n    it('should handle on-demand evaluation when variables change', () => {\n      const grid = [\n        ['L = 5', '=L * 2'],\n        ['', '']\n      ];\n      \n      // Initial evaluation\n      evaluateCell(grid, 'L = 5', 0, 0);\n      let resultB1 = evaluateCell(grid, '=L * 2', 0, 1);\n      expect(resultB1).toBe(10);\n      \n      // Change L to 8 and re-evaluate\n      clearVariablesInCell('0:0');\n      grid[0][0] = 'L = 8';\n      evaluateCell(grid, 'L = 8', 0, 0);\n      \n      // B1 should now return 16 when re-evaluated\n      resultB1 = evaluateCell(grid, '=L * 2', 0, 1);\n      expect(resultB1).toBe(16);\n    });\n\n    it('should handle multiple dependent cells', () => {\n      const grid = [\n        ['L = 10', '=L * 2', '=L + 5'],\n        ['', '=L / 2', '=L * L']\n      ];\n      \n      // Define base variable\n      evaluateCell(grid, 'L = 10', 0, 0);\n      \n      // All dependent cells should work\n      expect(evaluateCell(grid, '=L * 2', 0, 1)).toBe(20);\n      expect(evaluateCell(grid, '=L + 5', 0, 2)).toBe(15);\n      expect(evaluateCell(grid, '=L / 2', 1, 1)).toBe(5);\n      expect(evaluateCell(grid, '=L * L', 1, 2)).toBe(100);\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle undefined variables gracefully', () => {\n      const grid = [\n        ['=UndefinedVar * 2', ''],\n        ['', '']\n      ];\n      \n      expect(() => {\n        evaluateCell(grid, '=UndefinedVar * 2', 0, 0);\n      }).toThrow('Undefined variable: UndefinedVar');\n    });\n\n    it('should handle invalid expressions in variable assignments', () => {\n      const grid = [\n        ['L = InvalidExpression', ''],\n        ['', '']\n      ];\n      \n      expect(() => {\n        evaluateCell(grid, 'L = InvalidExpression', 0, 0);\n      }).toThrow();\n    });\n  });\n});","size_bytes":6588},"src/engine/test-unified.ts":{"content":"// Quick test to verify unified system works\nimport { evaluateExpression } from './unified-integration';\n\nconsole.log(\"Testing unified parser:\");\n\ntry {\n  console.log(\"L*W test:\", evaluateExpression(\"5*4\"));\n  console.log(\"L*W with units:\", evaluateExpression(\"5 ft * 4 ft\"));\n  console.log(\"LaTeX conversion test:\", evaluateExpression(\"5 \\\\cdot 4\"));\n} catch (error) {\n  console.error(\"Test failed:\", error);\n}","size_bytes":411},"test-multiplication-fix.js":{"content":"// Test script to verify the multiplication fix in ReportPad model\n// This tests that normalizeForParser correctly handles LaTeX symbols\n\nimport { lex, parseExpr, evalExpr, makeQuantity } from './src/frames/ReportPad/model.js';\nimport { normalizeForParser } from './src/lib/text/normalize.js';\n\nconsole.log('Testing multiplication fix...');\n\n// Test 1: Basic LaTeX cdot conversion\nconsole.log('\\n1. Testing LaTeX \\\\cdot conversion:');\nconst input1 = 'L \\\\cdot W';\nconst normalized1 = normalizeForParser(input1);\nconsole.log(`Input: \"${input1}\"`);\nconsole.log(`Normalized: \"${normalized1}\"`);\nconsole.log(`Expected: \"L * W\"`);\nconsole.log(`✓ Test 1 ${normalized1 === 'L * W' ? 'PASSED' : 'FAILED'}`);\n\n// Test 2: Test lexer with LaTeX symbols\nconsole.log('\\n2. Testing lexer with LaTeX symbols:');\ntry {\n  const tokens1 = lex('5 \\\\cdot 3');\n  console.log(`Tokens for \"5 \\\\cdot 3\":`, tokens1);\n  console.log(`✓ Test 2 PASSED - Lexer handles \\\\cdot`);\n} catch (e) {\n  console.log(`✗ Test 2 FAILED - Lexer error:`, e.message);\n}\n\n// Test 3: Test various multiplication symbols\nconsole.log('\\n3. Testing various multiplication symbols:');\nconst testCases = [\n  'a * b',\n  'a \\\\cdot b', \n  'a \\\\times b',\n  'a · b',\n  'a × b'\n];\n\ntestCases.forEach((testCase, i) => {\n  try {\n    const tokens = lex(testCase);\n    const hasMultiply = tokens.some(t => t.t === 'OP' && t.v === '*');\n    console.log(`\"${testCase}\" → ${hasMultiply ? '✓ PASSED' : '✗ FAILED'} (has multiply operator)`);\n  } catch (e) {\n    console.log(`\"${testCase}\" → ✗ FAILED (${e.message})`);\n  }\n});\n\n// Test 4: Complete expression parsing\nconsole.log('\\n4. Testing complete expression parsing:');\ntry {\n  const tokens = lex('L \\\\cdot W + 5');\n  const ast = parseExpr(tokens);\n  console.log(`AST for \"L \\\\cdot W + 5\":`, JSON.stringify(ast, null, 2));\n  console.log(`✓ Test 4 PASSED - Complete expression parsing works`);\n} catch (e) {\n  console.log(`✗ Test 4 FAILED - Parse error:`, e.message);\n}\n\nconsole.log('\\n✅ Multiplication fix testing completed!');","size_bytes":2038},"src/unified_parser.ts":{"content":"// Single Unified Parser - Handles ALL parsing, evaluation, and math in the entire application\n// Replaces: engine/eval.ts, engine/unified-*, parser/*, parsing/*, ReportPad model parsing, etc.\n\nimport { normalizeForParser } from './lib/text/normalize';\nimport { defineVariable, resolveVariable, defineVariableInCell, getVariableDefiningCell, clearVariablesInCell } from './referencing/names';\n\n// ============================================================================\n// TYPES - Single unified type system\n// ============================================================================\n\nexport type Token = \n  | { type: 'NUMBER'; value: number }\n  | { type: 'UNIT'; value: string }\n  | { type: 'IDENTIFIER'; value: string }\n  | { type: 'CELL_REF'; value: string }\n  | { type: 'RANGE'; value: string } // A1:B10\n  | { type: 'OPERATOR'; value: '+' | '-' | '*' | '/' | '^' | '=' }\n  | { type: 'LPAREN'; value?: undefined }\n  | { type: 'RPAREN'; value?: undefined }\n  | { type: 'COMMA'; value?: undefined };\n\nexport type Expr =\n  | { kind: 'number'; value: number; unit?: string }\n  | { kind: 'variable'; name: string }\n  | { kind: 'cell'; ref: string }\n  | { kind: 'range'; start: string; end: string }\n  | { kind: 'binary'; op: '+' | '-' | '*' | '/' | '^'; left: Expr; right: Expr }\n  | { kind: 'call'; func: string; args: Expr[] }\n  | { kind: 'assign'; name: string; expr: Expr };\n\nexport type ParseResult = \n  | { kind: 'assignment'; name: string; expr: Expr }\n  | { kind: 'expression'; expr: Expr }\n  | { kind: 'text'; text: string };\n\nexport type Quantity = {\n  value: number;\n  unit?: string;\n  valueSI: number;\n  dims: { L: number; M: number; T: number; F: number };\n  displayUnit?: string;\n};\n\nexport type EvaluationContext = {\n  getCell?: (ref: string) => string;\n  setVariable?: (name: string, value: Quantity) => void;\n  getVariable?: (name: string) => Quantity | undefined;\n  grid?: string[][];\n  cellKey?: string; // For cycle detection\n  visiting?: Set<string>;\n};\n\n// ============================================================================\n// UNIT SYSTEM - Consolidated from all scattered implementations\n// ============================================================================\n\nconst UNIT_REGISTRY: Record<string, { dims: { L: number; M: number; T: number; F: number }; toSI: number; fromSI: number }> = {\n  // Length\n  in: { dims: { L: 1, M: 0, T: 0, F: 0 }, toSI: 0.0254, fromSI: 39.37007874 },\n  ft: { dims: { L: 1, M: 0, T: 0, F: 0 }, toSI: 0.3048, fromSI: 3.280839895 },\n  yd: { dims: { L: 1, M: 0, T: 0, F: 0 }, toSI: 0.9144, fromSI: 1.0936132983 },\n  mm: { dims: { L: 1, M: 0, T: 0, F: 0 }, toSI: 0.001, fromSI: 1000 },\n  cm: { dims: { L: 1, M: 0, T: 0, F: 0 }, toSI: 0.01, fromSI: 100 },\n  m: { dims: { L: 1, M: 0, T: 0, F: 0 }, toSI: 1, fromSI: 1 },\n  km: { dims: { L: 1, M: 0, T: 0, F: 0 }, toSI: 1000, fromSI: 0.001 },\n  mil: { dims: { L: 1, M: 0, T: 0, F: 0 }, toSI: 0.0000254, fromSI: 39370.07874 },\n  \n  // Force\n  N: { dims: { L: 0, M: 0, T: 0, F: 1 }, toSI: 1, fromSI: 1 },\n  kN: { dims: { L: 0, M: 0, T: 0, F: 1 }, toSI: 1000, fromSI: 0.001 },\n  lb: { dims: { L: 0, M: 0, T: 0, F: 1 }, toSI: 4.4482216153, fromSI: 0.2248089431 },\n  lbs: { dims: { L: 0, M: 0, T: 0, F: 1 }, toSI: 4.4482216153, fromSI: 0.2248089431 },\n  kip: { dims: { L: 0, M: 0, T: 0, F: 1 }, toSI: 4448.2216153, fromSI: 0.0002248089431 },\n  kg: { dims: { L: 0, M: 1, T: 0, F: 0 }, toSI: 1, fromSI: 1 },\n  \n  // Pressure\n  Pa: { dims: { L: -2, M: 0, T: 0, F: 1 }, toSI: 1, fromSI: 1 },\n  kPa: { dims: { L: -2, M: 0, T: 0, F: 1 }, toSI: 1000, fromSI: 0.001 },\n  MPa: { dims: { L: -2, M: 0, T: 0, F: 1 }, toSI: 1000000, fromSI: 0.000001 },\n  GPa: { dims: { L: -2, M: 0, T: 0, F: 1 }, toSI: 1000000000, fromSI: 0.000000001 },\n  psi: { dims: { L: -2, M: 0, T: 0, F: 1 }, toSI: 6894.75729, fromSI: 0.000145037738 },\n  psf: { dims: { L: -2, M: 0, T: 0, F: 1 }, toSI: 47.8802589, fromSI: 0.0208854342 },\n  ksi: { dims: { L: -2, M: 0, T: 0, F: 1 }, toSI: 6894757.29, fromSI: 0.000000145037738 },\n  \n  // Time\n  s: { dims: { L: 0, M: 0, T: 1, F: 0 }, toSI: 1, fromSI: 1 },\n  sec: { dims: { L: 0, M: 0, T: 1, F: 0 }, toSI: 1, fromSI: 1 },\n  \n  // Angle\n  deg: { dims: { L: 0, M: 0, T: 0, F: 0 }, toSI: Math.PI / 180, fromSI: 180 / Math.PI },\n  rad: { dims: { L: 0, M: 0, T: 0, F: 0 }, toSI: 1, fromSI: 1 },\n};\n\nfunction makeQuantity(value: number, unit?: string): Quantity {\n  if (!unit || !UNIT_REGISTRY[unit]) {\n    return { value, valueSI: value, dims: { L: 0, M: 0, T: 0, F: 0 }, displayUnit: unit };\n  }\n  \n  const unitDef = UNIT_REGISTRY[unit];\n  return {\n    value,\n    unit,\n    valueSI: value * unitDef.toSI,\n    dims: unitDef.dims,\n    displayUnit: unit\n  };\n}\n\nfunction dimsEqual(a: { L: number; M: number; T: number; F: number }, b: { L: number; M: number; T: number; F: number }): boolean {\n  return a.L === b.L && a.M === b.M && a.T === b.T && a.F === b.F;\n}\n\nfunction combineDims(a: { L: number; M: number; T: number; F: number }, b: { L: number; M: number; T: number; F: number }, op: '*' | '/'): { L: number; M: number; T: number; F: number } {\n  if (op === '*') {\n    return { L: a.L + b.L, M: a.M + b.M, T: a.T + b.T, F: a.F + b.F };\n  } else {\n    return { L: a.L - b.L, M: a.M - b.M, T: a.T - b.T, F: a.F - b.F };\n  }\n}\n\n// ============================================================================\n// TOKENIZER - Handles all token types\n// ============================================================================\n\nfunction tokenize(input: string): Token[] {\n  const normalized = normalizeForParser(input);\n  const tokens: Token[] = [];\n  let i = 0;\n  \n  while (i < normalized.length) {\n    // Skip whitespace\n    if (/\\s/.test(normalized[i])) {\n      i++;\n      continue;\n    }\n    \n    // Numbers\n    if (/\\d/.test(normalized[i])) {\n      let numStr = '';\n      while (i < normalized.length && /[\\d\\.]/.test(normalized[i])) {\n        numStr += normalized[i];\n        i++;\n      }\n      tokens.push({ type: 'NUMBER', value: parseFloat(numStr) });\n      continue;\n    }\n    \n    // Cell ranges (A1:B10)\n    const rangeMatch = normalized.slice(i).match(/^([A-Z]+\\d+):([A-Z]+\\d+)/);\n    if (rangeMatch) {\n      tokens.push({ type: 'RANGE', value: rangeMatch[0] });\n      i += rangeMatch[0].length;\n      continue;\n    }\n    \n    // Cell references (A1, B2, etc.)\n    const cellMatch = normalized.slice(i).match(/^[A-Z]+\\d+/);\n    if (cellMatch) {\n      tokens.push({ type: 'CELL_REF', value: cellMatch[0] });\n      i += cellMatch[0].length;\n      continue;\n    }\n    \n    // Identifiers/Variables/Units\n    if (/[A-Za-z]/.test(normalized[i])) {\n      let identifier = '';\n      while (i < normalized.length && /[A-Za-z0-9_']/.test(normalized[i])) {\n        identifier += normalized[i];\n        i++;\n      }\n      \n      // Check if it's a known unit\n      if (UNIT_REGISTRY[identifier]) {\n        tokens.push({ type: 'UNIT', value: identifier });\n      } else {\n        tokens.push({ type: 'IDENTIFIER', value: identifier });\n      }\n      continue;\n    }\n    \n    // Operators and punctuation\n    const char = normalized[i];\n    if (['+', '-', '*', '/', '^', '='].includes(char)) {\n      tokens.push({ type: 'OPERATOR', value: char as any });\n      i++;\n    } else if (char === '(') {\n      tokens.push({ type: 'LPAREN' });\n      i++;\n    } else if (char === ')') {\n      tokens.push({ type: 'RPAREN' });\n      i++;\n    } else if (char === ',') {\n      tokens.push({ type: 'COMMA' });\n      i++;\n    } else {\n      throw new Error(`Unexpected character: ${char}`);\n    }\n  }\n  \n  return tokens;\n}\n\n// ============================================================================\n// PARSER - Recursive descent with proper precedence\n// ============================================================================\n\nexport function parse(input: string): ParseResult {\n  const tokens = tokenize(input);\n  let pos = 0;\n  \n  const peek = () => tokens[pos];\n  const consume = () => tokens[pos++];\n  const isAtEnd = () => pos >= tokens.length;\n  \n  // Check for assignment\n  if (tokens.length >= 3 && \n      tokens[0].type === 'IDENTIFIER' && \n      tokens[1].type === 'OPERATOR' && \n      tokens[1].value === '=') {\n    const name = consume().value as string;\n    consume(); // =\n    const expr = parseExpression();\n    return { kind: 'assignment', name, expr };\n  }\n  \n  // Try to parse as expression\n  try {\n    const expr = parseExpression();\n    return { kind: 'expression', expr };\n  } catch (error) {\n    // Fallback to text\n    return { kind: 'text', text: input };\n  }\n  \n  function parseExpression(): Expr {\n    return parseAddSub();\n  }\n  \n  function parseAddSub(): Expr {\n    let left = parseMulDiv();\n    \n    while (!isAtEnd() && peek().type === 'OPERATOR' && ['+', '-'].includes(peek().value as string)) {\n      const op = consume().value as '+' | '-';\n      const right = parseMulDiv();\n      left = { kind: 'binary', op, left, right };\n    }\n    \n    return left;\n  }\n  \n  function parseMulDiv(): Expr {\n    let left = parsePower();\n    \n    while (!isAtEnd() && peek().type === 'OPERATOR' && ['*', '/'].includes(peek().value as string)) {\n      const op = consume().value as '*' | '/';\n      const right = parsePower();\n      left = { kind: 'binary', op, left, right };\n    }\n    \n    return left;\n  }\n  \n  function parsePower(): Expr {\n    let left = parsePrimary();\n    \n    if (!isAtEnd() && peek().type === 'OPERATOR' && peek().value === '^') {\n      consume(); // ^\n      const right = parsePower(); // Right associative\n      left = { kind: 'binary', op: '^', left, right };\n    }\n    \n    return left;\n  }\n  \n  function parsePrimary(): Expr {\n    const token = peek();\n    \n    if (!token) {\n      throw new Error('Unexpected end of expression');\n    }\n    \n    // Parentheses\n    if (token.type === 'LPAREN') {\n      consume(); // (\n      const expr = parseExpression();\n      if (!peek() || peek().type !== 'RPAREN') {\n        throw new Error('Expected closing parenthesis');\n      }\n      consume(); // )\n      return expr;\n    }\n    \n    // Numbers\n    if (token.type === 'NUMBER') {\n      const value = consume().value as number;\n      \n      // Check for unit after number\n      const nextToken = peek();\n      if (nextToken && nextToken.type === 'UNIT') {\n        const unit = consume().value as string;\n        return { kind: 'number', value, unit };\n      }\n      \n      return { kind: 'number', value };\n    }\n    \n    // Cell references\n    if (token.type === 'CELL_REF') {\n      const ref = consume().value as string;\n      return { kind: 'cell', ref };\n    }\n    \n    // Ranges\n    if (token.type === 'RANGE') {\n      const range = consume().value as string;\n      const [start, end] = range.split(':');\n      return { kind: 'range', start, end };\n    }\n    \n    // Identifiers (variables or functions)\n    if (token.type === 'IDENTIFIER') {\n      const name = consume().value as string;\n      \n      // Check for function call\n      if (peek() && peek().type === 'LPAREN') {\n        consume(); // (\n        const args: Expr[] = [];\n        \n        if (!peek() || peek().type !== 'RPAREN') {\n          args.push(parseExpression());\n          while (peek() && peek().type === 'COMMA') {\n            consume(); // ,\n            args.push(parseExpression());\n          }\n        }\n        \n        if (!peek() || peek().type !== 'RPAREN') {\n          throw new Error('Expected closing parenthesis');\n        }\n        consume(); // )\n        \n        return { kind: 'call', func: name, args };\n      }\n      \n      // Variable\n      return { kind: 'variable', name };\n    }\n    \n    throw new Error(`Unexpected token: ${JSON.stringify(token)}`);\n  }\n}\n\n// ============================================================================\n// EVALUATOR - Handles all evaluation contexts\n// ============================================================================\n\nexport function evaluate(input: string, context: EvaluationContext = {}): Quantity {\n  const parsed = parse(input);\n  \n  if (parsed.kind === 'assignment') {\n    const value = evaluateExpr(parsed.expr, context);\n    \n    // Store variable\n    if (context.setVariable) {\n      context.setVariable(parsed.name, value);\n    } else {\n      defineVariable(parsed.name, value.value);\n    }\n    \n    return value;\n  } else if (parsed.kind === 'expression') {\n    return evaluateExpr(parsed.expr, context);\n  } else {\n    throw new Error('Cannot evaluate text');\n  }\n}\n\nfunction evaluateExpr(expr: Expr, context: EvaluationContext): Quantity {\n  switch (expr.kind) {\n    case 'number':\n      return makeQuantity(expr.value, expr.unit);\n      \n    case 'variable': {\n      // Try context first\n      let varValue = context.getVariable?.(expr.name);\n      if (varValue !== undefined) return varValue;\n      \n      // Try global store\n      const globalValue = resolveVariable(expr.name);\n      if (globalValue !== undefined) {\n        return makeQuantity(globalValue);\n      }\n      \n      // Try unit lookup (bare unit = 1 unit)\n      if (UNIT_REGISTRY[expr.name]) {\n        return makeQuantity(1, expr.name);\n      }\n      \n      throw new Error(`Undefined variable: ${expr.name}`);\n    }\n    \n    case 'cell': {\n      if (!context.getCell) {\n        throw new Error('Cell references not supported in this context');\n      }\n      \n      const cellContent = context.getCell(expr.ref);\n      if (!cellContent) {\n        return makeQuantity(0);\n      }\n      \n      // Parse cell content as number with optional unit\n      const numMatch = cellContent.match(/^\\s*(\\d+(?:\\.\\d+)?)\\s*([A-Za-z]+)?\\s*$/);\n      if (numMatch) {\n        const value = parseFloat(numMatch[1]);\n        const unit = numMatch[2];\n        return makeQuantity(value, unit);\n      }\n      \n      // Try to recursively evaluate cell content\n      try {\n        return evaluate(cellContent, context);\n      } catch {\n        const num = parseFloat(cellContent);\n        if (isFinite(num)) {\n          return makeQuantity(num);\n        }\n        throw new Error(`Invalid cell value: ${expr.ref}`);\n      }\n    }\n    \n    case 'binary': {\n      const left = evaluateExpr(expr.left, context);\n      const right = evaluateExpr(expr.right, context);\n      \n      switch (expr.op) {\n        case '+':\n        case '-': {\n          if (!dimsEqual(left.dims, right.dims)) {\n            throw new Error('Cannot add/subtract incompatible units');\n          }\n          const rightValue = expr.op === '+' ? right.valueSI : -right.valueSI;\n          return {\n            value: left.value + right.value * (expr.op === '+' ? 1 : -1),\n            valueSI: left.valueSI + rightValue,\n            dims: left.dims,\n            unit: left.unit || right.unit,\n            displayUnit: left.displayUnit || right.displayUnit\n          };\n        }\n        \n        case '*': {\n          return {\n            value: left.value * right.value,\n            valueSI: left.valueSI * right.valueSI,\n            dims: combineDims(left.dims, right.dims, '*'),\n            unit: combineUnits('*', left.unit, right.unit),\n            displayUnit: combineUnits('*', left.displayUnit, right.displayUnit)\n          };\n        }\n        \n        case '/': {\n          if (right.value === 0) {\n            throw new Error('Division by zero');\n          }\n          return {\n            value: left.value / right.value,\n            valueSI: left.valueSI / right.valueSI,\n            dims: combineDims(left.dims, right.dims, '/'),\n            unit: combineUnits('/', left.unit, right.unit),\n            displayUnit: combineUnits('/', left.displayUnit, right.displayUnit)\n          };\n        }\n        \n        case '^': {\n          if (!dimsEqual(right.dims, { L: 0, M: 0, T: 0, F: 0 })) {\n            throw new Error('Exponent must be dimensionless');\n          }\n          const exp = right.valueSI;\n          return {\n            value: Math.pow(left.value, exp),\n            valueSI: Math.pow(left.valueSI, exp),\n            dims: {\n              L: left.dims.L * exp,\n              M: left.dims.M * exp,\n              T: left.dims.T * exp,\n              F: left.dims.F * exp\n            },\n            unit: left.unit ? `${left.unit}^${exp}` : undefined,\n            displayUnit: left.displayUnit ? `${left.displayUnit}^${exp}` : undefined\n          };\n        }\n        \n        default:\n          throw new Error(`Unknown operator: ${expr.op}`);\n      }\n    }\n    \n    case 'call': {\n      if (expr.func.toUpperCase() === 'VLOOKUP') {\n        // Implement VLOOKUP logic here if needed\n        throw new Error('VLOOKUP not implemented in unified parser yet');\n      }\n      throw new Error(`Unknown function: ${expr.func}`);\n    }\n    \n    case 'range':\n      throw new Error('Ranges cannot be evaluated directly');\n      \n    default:\n      throw new Error('Unknown expression type');\n  }\n}\n\nfunction combineUnits(op: '*' | '/', left?: string, right?: string): string | undefined {\n  if (!left && !right) return undefined;\n  if (!left) return right;\n  if (!right) return left;\n  \n  if (op === '*') {\n    return `${left}·${right}`;\n  } else {\n    return `${left}/${right}`;\n  }\n}\n\n// ============================================================================\n// LEGACY COMPATIBILITY - For gradual migration\n// ============================================================================\n\n// A1 reference conversion\nexport function refToRC(ref: string): { r: number; c: number } | null {\n  const match = ref.match(/^([A-Z]+)(\\d+)$/);\n  if (!match) return null;\n  \n  const col = match[1];\n  const row = parseInt(match[2], 10) - 1;\n  \n  let c = 0;\n  for (let i = 0; i < col.length; i++) {\n    c = c * 26 + (col.charCodeAt(i) - 64);\n  }\n  c -= 1;\n  \n  return { r: row, c };\n}\n\n// Grid-based evaluation (for spreadsheet compatibility)\nexport function evaluateWithGrid(grid: string[][], input: string, cellKey?: string): number {\n  const context: EvaluationContext = {\n    getCell: (ref: string) => {\n      const rc = refToRC(ref);\n      if (!rc) throw new Error(`Invalid cell reference: ${ref}`);\n      return grid[rc.r]?.[rc.c] ?? '';\n    },\n    grid,\n    cellKey,\n    visiting: new Set()\n  };\n  \n  const result = evaluate(input, context);\n  return result.valueSI;\n}\n\n// Format result for display\nexport function formatQuantity(quantity: Quantity): string {\n  if (quantity.unit) {\n    return `${quantity.value} ${quantity.unit}`;\n  }\n  return quantity.value.toString();\n}\n\n// Classification helper\nexport function classifyInput(input: string): 'assignment' | 'expression' | 'text' {\n  try {\n    const parsed = parse(input);\n    return parsed.kind;\n  } catch {\n    return 'text';\n  }\n}\n\n// Export main functions\nexport { parse as parseExpression };\nexport { evaluate as evaluateExpression };","size_bytes":18634}},"version":1}